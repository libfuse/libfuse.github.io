<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.8"/>
<title>fuse: fuse_operations Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">fuse
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.8 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="functions.html"><span>Data&#160;Fields</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-attribs">Data Fields</a>  </div>
  <div class="headertitle">
<div class="title">fuse_operations Struct Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;fuse.h&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Data Fields</h2></td></tr>
<tr class="memitem:a7a4c5d8eaf7179d819618c0cf3f73724"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfuse__operations.html#a7a4c5d8eaf7179d819618c0cf3f73724">getattr</a> )(const char *, struct stat *)</td></tr>
<tr class="separator:a7a4c5d8eaf7179d819618c0cf3f73724"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4ce6e6d69dfde3ec550f22d932c5633"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfuse__operations.html#ab4ce6e6d69dfde3ec550f22d932c5633">readlink</a> )(const char *, char *, size_t)</td></tr>
<tr class="separator:ab4ce6e6d69dfde3ec550f22d932c5633"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1465eb2268cec2bb5ed11cb09bbda42f"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfuse__operations.html#a1465eb2268cec2bb5ed11cb09bbda42f">mknod</a> )(const char *, mode_t, dev_t)</td></tr>
<tr class="separator:a1465eb2268cec2bb5ed11cb09bbda42f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a38aa6ca60e945772d5d21b0c1c8916"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfuse__operations.html#a0a38aa6ca60e945772d5d21b0c1c8916">mkdir</a> )(const char *, mode_t)</td></tr>
<tr class="separator:a0a38aa6ca60e945772d5d21b0c1c8916"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bf63301a9d6e94311fa10480993801e"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfuse__operations.html#a8bf63301a9d6e94311fa10480993801e">unlink</a> )(const char *)</td></tr>
<tr class="separator:a8bf63301a9d6e94311fa10480993801e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac59578d18db12f0142ae1ab6e8812d55"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfuse__operations.html#ac59578d18db12f0142ae1ab6e8812d55">rmdir</a> )(const char *)</td></tr>
<tr class="separator:ac59578d18db12f0142ae1ab6e8812d55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab86022391e56a8ad3211cf754b5b5ebe"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfuse__operations.html#ab86022391e56a8ad3211cf754b5b5ebe">symlink</a> )(const char *, const char *)</td></tr>
<tr class="separator:ab86022391e56a8ad3211cf754b5b5ebe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa777cbddc91887b117ac414e9a2d3cb5"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfuse__operations.html#aa777cbddc91887b117ac414e9a2d3cb5">rename</a> )(const char *, const char *)</td></tr>
<tr class="separator:aa777cbddc91887b117ac414e9a2d3cb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b234c43e826c6a690d80ea895a17f61"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfuse__operations.html#a1b234c43e826c6a690d80ea895a17f61">link</a> )(const char *, const char *)</td></tr>
<tr class="separator:a1b234c43e826c6a690d80ea895a17f61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e75d299efe3a401e8473af7028e5cc5"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfuse__operations.html#a7e75d299efe3a401e8473af7028e5cc5">chmod</a> )(const char *, mode_t)</td></tr>
<tr class="separator:a7e75d299efe3a401e8473af7028e5cc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40421f8a43e903582c49897894f4692d"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfuse__operations.html#a40421f8a43e903582c49897894f4692d">chown</a> )(const char *, uid_t, gid_t)</td></tr>
<tr class="separator:a40421f8a43e903582c49897894f4692d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8efb50b9cd975ba8c4c450248caff6ed"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfuse__operations.html#a8efb50b9cd975ba8c4c450248caff6ed">truncate</a> )(const char *, off_t)</td></tr>
<tr class="separator:a8efb50b9cd975ba8c4c450248caff6ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb7452acad1002d418409892b6e54c2e"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfuse__operations.html#acb7452acad1002d418409892b6e54c2e">utime</a> )(const char *, struct utimbuf *)</td></tr>
<tr class="separator:acb7452acad1002d418409892b6e54c2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14b98c3f7ab97cc2ef8f9b1d9dc0709d"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfuse__operations.html#a14b98c3f7ab97cc2ef8f9b1d9dc0709d">open</a> )(const char *, struct <a class="el" href="structfuse__file__info.html">fuse_file_info</a> *)</td></tr>
<tr class="separator:a14b98c3f7ab97cc2ef8f9b1d9dc0709d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a1c6b4ce1845de56863f8b7939501b5"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfuse__operations.html#a2a1c6b4ce1845de56863f8b7939501b5">read</a> )(const char *, char *, size_t, off_t, struct <a class="el" href="structfuse__file__info.html">fuse_file_info</a> *)</td></tr>
<tr class="separator:a2a1c6b4ce1845de56863f8b7939501b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a897d1ece4b8b04c92d97b97b2dbf9768"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfuse__operations.html#a897d1ece4b8b04c92d97b97b2dbf9768">write</a> )(const char *, const char *, size_t, off_t, struct <a class="el" href="structfuse__file__info.html">fuse_file_info</a> *)</td></tr>
<tr class="separator:a897d1ece4b8b04c92d97b97b2dbf9768"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e765e29122e7b6b533dc99849a52655"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfuse__operations.html#a4e765e29122e7b6b533dc99849a52655">statfs</a> )(const char *, struct statvfs *)</td></tr>
<tr class="separator:a4e765e29122e7b6b533dc99849a52655"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4ec9c309072a92dd82ddb20efa4ab14"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfuse__operations.html#ad4ec9c309072a92dd82ddb20efa4ab14">flush</a> )(const char *, struct <a class="el" href="structfuse__file__info.html">fuse_file_info</a> *)</td></tr>
<tr class="separator:ad4ec9c309072a92dd82ddb20efa4ab14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abac8718cdfc1ee273a44831a27393419"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfuse__operations.html#abac8718cdfc1ee273a44831a27393419">release</a> )(const char *, struct <a class="el" href="structfuse__file__info.html">fuse_file_info</a> *)</td></tr>
<tr class="separator:abac8718cdfc1ee273a44831a27393419"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92bdd6f43ba390a54ac360541c56b528"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfuse__operations.html#a92bdd6f43ba390a54ac360541c56b528">fsync</a> )(const char *, int, struct <a class="el" href="structfuse__file__info.html">fuse_file_info</a> *)</td></tr>
<tr class="separator:a92bdd6f43ba390a54ac360541c56b528"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a988ced7091c2821daa208e6c96d8b598"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfuse__operations.html#a988ced7091c2821daa208e6c96d8b598">setxattr</a> )(const char *, const char *, const char *, size_t, int)</td></tr>
<tr class="separator:a988ced7091c2821daa208e6c96d8b598"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae21503c64fe2990c8a599f5ba339a8f2"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfuse__operations.html#ae21503c64fe2990c8a599f5ba339a8f2">getxattr</a> )(const char *, const char *, char *, size_t)</td></tr>
<tr class="separator:ae21503c64fe2990c8a599f5ba339a8f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4a9c361ce48406f07d5a08ab03f5de8"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfuse__operations.html#ab4a9c361ce48406f07d5a08ab03f5de8">listxattr</a> )(const char *, char *, size_t)</td></tr>
<tr class="separator:ab4a9c361ce48406f07d5a08ab03f5de8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e54de801a0e0d7019e4579112ecc477"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfuse__operations.html#a5e54de801a0e0d7019e4579112ecc477">removexattr</a> )(const char *, const char *)</td></tr>
<tr class="separator:a5e54de801a0e0d7019e4579112ecc477"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1813889bc5e6e0087a936b7abe8b923f"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfuse__operations.html#a1813889bc5e6e0087a936b7abe8b923f">opendir</a> )(const char *, struct <a class="el" href="structfuse__file__info.html">fuse_file_info</a> *)</td></tr>
<tr class="separator:a1813889bc5e6e0087a936b7abe8b923f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f634deda31d1e1c42664585ae820076"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfuse__operations.html#a0f634deda31d1e1c42664585ae820076">readdir</a> )(const char *, void *, <a class="el" href="fuse_8h.html#ae2a2054f9852fd6020c26a1bcc7f1042">fuse_fill_dir_t</a>, off_t, struct <a class="el" href="structfuse__file__info.html">fuse_file_info</a> *)</td></tr>
<tr class="separator:a0f634deda31d1e1c42664585ae820076"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a729e53d36acc05a7a8985a1a3bbfac1e"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfuse__operations.html#a729e53d36acc05a7a8985a1a3bbfac1e">releasedir</a> )(const char *, struct <a class="el" href="structfuse__file__info.html">fuse_file_info</a> *)</td></tr>
<tr class="separator:a729e53d36acc05a7a8985a1a3bbfac1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba5cc1fe9a63ec152ceb19656f243256"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfuse__operations.html#aba5cc1fe9a63ec152ceb19656f243256">fsyncdir</a> )(const char *, int, struct <a class="el" href="structfuse__file__info.html">fuse_file_info</a> *)</td></tr>
<tr class="separator:aba5cc1fe9a63ec152ceb19656f243256"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc6dc71274f185de72217e38d62142c4"><td class="memItemLeft" align="right" valign="top">void *(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfuse__operations.html#adc6dc71274f185de72217e38d62142c4">init</a> )(struct <a class="el" href="structfuse__conn__info.html">fuse_conn_info</a> *conn)</td></tr>
<tr class="separator:adc6dc71274f185de72217e38d62142c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac41d37ab860204fe4bd7612f9fb036c5"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfuse__operations.html#ac41d37ab860204fe4bd7612f9fb036c5">destroy</a> )(void *)</td></tr>
<tr class="separator:ac41d37ab860204fe4bd7612f9fb036c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2248db35e200265f7fb9a18348229858"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfuse__operations.html#a2248db35e200265f7fb9a18348229858">access</a> )(const char *, int)</td></tr>
<tr class="separator:a2248db35e200265f7fb9a18348229858"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97243e0f9268a96236bc3b6f2bacee17"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfuse__operations.html#a97243e0f9268a96236bc3b6f2bacee17">create</a> )(const char *, mode_t, struct <a class="el" href="structfuse__file__info.html">fuse_file_info</a> *)</td></tr>
<tr class="separator:a97243e0f9268a96236bc3b6f2bacee17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e492882859740f13cbf3344cf963c70"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfuse__operations.html#a1e492882859740f13cbf3344cf963c70">ftruncate</a> )(const char *, off_t, struct <a class="el" href="structfuse__file__info.html">fuse_file_info</a> *)</td></tr>
<tr class="separator:a1e492882859740f13cbf3344cf963c70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a573d79862df591c98e1685225a4cd3a5"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfuse__operations.html#a573d79862df591c98e1685225a4cd3a5">fgetattr</a> )(const char *, struct stat *, struct <a class="el" href="structfuse__file__info.html">fuse_file_info</a> *)</td></tr>
<tr class="separator:a573d79862df591c98e1685225a4cd3a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c3fff5cf0c1c2003d117e764b9a76fd"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfuse__operations.html#a1c3fff5cf0c1c2003d117e764b9a76fd">lock</a> )(const char *, struct <a class="el" href="structfuse__file__info.html">fuse_file_info</a> *, int cmd, struct <a class="el" href="structfuse__operations.html#ad5968d566dab370974043fcf4271eb25">flock</a> *)</td></tr>
<tr class="separator:a1c3fff5cf0c1c2003d117e764b9a76fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79955861cc5eb006954476607ef28944"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfuse__operations.html#a79955861cc5eb006954476607ef28944">utimens</a> )(const char *, const struct timespec tv[2])</td></tr>
<tr class="separator:a79955861cc5eb006954476607ef28944"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3f3482e33a0eada0292350d76b82901"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfuse__operations.html#ae3f3482e33a0eada0292350d76b82901">bmap</a> )(const char *, size_t blocksize, uint64_t *idx)</td></tr>
<tr class="separator:ae3f3482e33a0eada0292350d76b82901"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf5f08abeb39ab627fe1043d9a67cc09"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfuse__operations.html#acf5f08abeb39ab627fe1043d9a67cc09">flag_nullpath_ok</a>:1</td></tr>
<tr class="separator:acf5f08abeb39ab627fe1043d9a67cc09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd0d90b9b500f6607f9aad9ae07784d8"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfuse__operations.html#abd0d90b9b500f6607f9aad9ae07784d8">flag_nopath</a>:1</td></tr>
<tr class="separator:abd0d90b9b500f6607f9aad9ae07784d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ca87db7234e774e39de7b323e03455d"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfuse__operations.html#a0ca87db7234e774e39de7b323e03455d">flag_utime_omit_ok</a>:1</td></tr>
<tr class="separator:a0ca87db7234e774e39de7b323e03455d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab54bb9753d457ceff8240f67b1b6b72d"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfuse__operations.html#ab54bb9753d457ceff8240f67b1b6b72d">flag_reserved</a>:29</td></tr>
<tr class="separator:ab54bb9753d457ceff8240f67b1b6b72d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37f0612d67a6b76bf10fe6a71b0e3b5b"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfuse__operations.html#a37f0612d67a6b76bf10fe6a71b0e3b5b">ioctl</a> )(const char *, int cmd, void *arg, struct <a class="el" href="structfuse__file__info.html">fuse_file_info</a> *, unsigned int flags, void *data)</td></tr>
<tr class="separator:a37f0612d67a6b76bf10fe6a71b0e3b5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c02838d30391c09dd5213edc61e106a"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfuse__operations.html#a2c02838d30391c09dd5213edc61e106a">poll</a> )(const char *, struct <a class="el" href="structfuse__file__info.html">fuse_file_info</a> *, struct fuse_pollhandle *ph, unsigned *reventsp)</td></tr>
<tr class="separator:a2c02838d30391c09dd5213edc61e106a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89f400083a03ddcc43e47ce126b6761f"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfuse__operations.html#a89f400083a03ddcc43e47ce126b6761f">write_buf</a> )(const char *, struct <a class="el" href="structfuse__bufvec.html">fuse_bufvec</a> *buf, off_t off, struct <a class="el" href="structfuse__file__info.html">fuse_file_info</a> *)</td></tr>
<tr class="separator:a89f400083a03ddcc43e47ce126b6761f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ecbe844d937ffbbe135958bcb28a719"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfuse__operations.html#a1ecbe844d937ffbbe135958bcb28a719">read_buf</a> )(const char *, struct <a class="el" href="structfuse__bufvec.html">fuse_bufvec</a> **bufp, size_t size, off_t off, struct <a class="el" href="structfuse__file__info.html">fuse_file_info</a> *)</td></tr>
<tr class="separator:a1ecbe844d937ffbbe135958bcb28a719"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5968d566dab370974043fcf4271eb25"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfuse__operations.html#ad5968d566dab370974043fcf4271eb25">flock</a> )(const char *, struct <a class="el" href="structfuse__file__info.html">fuse_file_info</a> *, int op)</td></tr>
<tr class="separator:ad5968d566dab370974043fcf4271eb25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fa8203e4bfa71d62c15deb5dffe4867"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfuse__operations.html#a4fa8203e4bfa71d62c15deb5dffe4867">fallocate</a> )(const char *, int, off_t, off_t, struct <a class="el" href="structfuse__file__info.html">fuse_file_info</a> *)</td></tr>
<tr class="separator:a4fa8203e4bfa71d62c15deb5dffe4867"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The file system operations:</p>
<p>Most of these should work very similarly to the well known UNIX file system operations. A major exception is that instead of returning an error in 'errno', the operation should return the negated error value (-errno) directly.</p>
<p>All methods are optional, but some are essential for a useful filesystem (e.g. getattr). Open, flush, release, fsync, opendir, releasedir, fsyncdir, access, create, ftruncate, fgetattr, lock, init and destroy are special purpose methods, without which a full featured filesystem can still be implemented.</p>
<p>Almost all operations take a path which can be of any length.</p>
<p>Changed in fuse 2.8.0 (regardless of API version) Previously, paths were limited to a length of PATH_MAX.</p>
<p>See <a href="http://fuse.sourceforge.net/wiki/">http://fuse.sourceforge.net/wiki/</a> for more information. There is also a snapshot of the relevant wiki pages in the doc/ folder. </p>
</div><h2 class="groupheader">Field Documentation</h2>
<a class="anchor" id="a2248db35e200265f7fb9a18348229858"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* fuse_operations::access)(const char *, int)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check file access permissions</p>
<p>This will be called for the <a class="el" href="structfuse__operations.html#a2248db35e200265f7fb9a18348229858">access()</a> system call. If the 'default_permissions' mount option is given, this method is not called.</p>
<p>This method is not called under Linux kernel versions 2.4.x</p>
<p>Introduced in version 2.5 </p>

</div>
</div>
<a class="anchor" id="ae3f3482e33a0eada0292350d76b82901"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* fuse_operations::bmap)(const char *, size_t blocksize, uint64_t *idx)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Map block index within file to block index within device</p>
<p>Note: This makes sense only for block device backed filesystems mounted with the 'blkdev' option</p>
<p>Introduced in version 2.6 </p>

</div>
</div>
<a class="anchor" id="a7e75d299efe3a401e8473af7028e5cc5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* fuse_operations::chmod)(const char *, mode_t)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Change the permission bits of a file </p>

</div>
</div>
<a class="anchor" id="a40421f8a43e903582c49897894f4692d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* fuse_operations::chown)(const char *, uid_t, gid_t)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Change the owner and group of a file </p>

</div>
</div>
<a class="anchor" id="a97243e0f9268a96236bc3b6f2bacee17"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* fuse_operations::create)(const char *, mode_t, struct <a class="el" href="structfuse__file__info.html">fuse_file_info</a> *)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create and open a file</p>
<p>If the file does not exist, first create it with the specified mode, and then open it.</p>
<p>If this method is not implemented or under Linux kernel versions earlier than 2.6.15, the <a class="el" href="structfuse__operations.html#a1465eb2268cec2bb5ed11cb09bbda42f">mknod()</a> and <a class="el" href="structfuse__operations.html#a14b98c3f7ab97cc2ef8f9b1d9dc0709d">open()</a> methods will be called instead.</p>
<p>Introduced in version 2.5 </p>

</div>
</div>
<a class="anchor" id="ac41d37ab860204fe4bd7612f9fb036c5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* fuse_operations::destroy)(void *)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Clean up filesystem</p>
<p>Called on filesystem exit.</p>
<p>Introduced in version 2.3 </p>

</div>
</div>
<a class="anchor" id="a4fa8203e4bfa71d62c15deb5dffe4867"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* fuse_operations::fallocate)(const char *, int, off_t, off_t, struct <a class="el" href="structfuse__file__info.html">fuse_file_info</a> *)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Allocates space for an open file</p>
<p>This function ensures that required space is allocated for specified file. If this function returns success then any subsequent write request to specified range is guaranteed not to fail because of lack of space on the file system media.</p>
<p>Introduced in version 2.9.1 </p>

</div>
</div>
<a class="anchor" id="a573d79862df591c98e1685225a4cd3a5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* fuse_operations::fgetattr)(const char *, struct stat *, struct <a class="el" href="structfuse__file__info.html">fuse_file_info</a> *)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get attributes from an open file</p>
<p>This method is called instead of the <a class="el" href="structfuse__operations.html#a7a4c5d8eaf7179d819618c0cf3f73724">getattr()</a> method if the file information is available.</p>
<p>Currently this is only called after the <a class="el" href="structfuse__operations.html#a97243e0f9268a96236bc3b6f2bacee17">create()</a> method if that is implemented (see above). Later it may be called for invocations of fstat() too.</p>
<p>Introduced in version 2.5 </p>

</div>
</div>
<a class="anchor" id="abd0d90b9b500f6607f9aad9ae07784d8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int fuse_operations::flag_nopath</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Flag indicating that the path need not be calculated for the following operations:</p>
<p>read, write, flush, release, fsync, readdir, releasedir, fsyncdir, ftruncate, fgetattr, lock, ioctl and poll</p>
<p>Closely related to flag_nullpath_ok, but if this flag is set then the path will not be calculaged even if the file wasn't unlinked. However the path can still be non-NULL if it needs to be calculated for some other reason. </p>

</div>
</div>
<a class="anchor" id="acf5f08abeb39ab627fe1043d9a67cc09"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int fuse_operations::flag_nullpath_ok</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Flag indicating that the filesystem can accept a NULL path as the first argument for the following operations:</p>
<p>read, write, flush, release, fsync, readdir, releasedir, fsyncdir, ftruncate, fgetattr, lock, ioctl and poll</p>
<p>If this flag is set these operations continue to work on unlinked files even if "-ohard_remove" option was specified. </p>

</div>
</div>
<a class="anchor" id="ab54bb9753d457ceff8240f67b1b6b72d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int fuse_operations::flag_reserved</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reserved flags, don't set </p>

</div>
</div>
<a class="anchor" id="a0ca87db7234e774e39de7b323e03455d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int fuse_operations::flag_utime_omit_ok</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Flag indicating that the filesystem accepts special UTIME_NOW and UTIME_OMIT values in its utimens operation. </p>

</div>
</div>
<a class="anchor" id="ad5968d566dab370974043fcf4271eb25"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* fuse_operations::flock)(const char *, struct <a class="el" href="structfuse__file__info.html">fuse_file_info</a> *, int op)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Perform BSD file locking operation</p>
<p>The op argument will be either LOCK_SH, LOCK_EX or LOCK_UN</p>
<p>Nonblocking requests will be indicated by ORing LOCK_NB to the above operations</p>
<p>For more information see the flock(2) manual page.</p>
<p>Additionally fi-&gt;owner will be set to a value unique to this open file. This same value will be supplied to -&gt;<a class="el" href="structfuse__operations.html#abac8718cdfc1ee273a44831a27393419">release()</a> when the file is released.</p>
<p>Note: if this method is not implemented, the kernel will still allow file locking to work locally. Hence it is only interesting for network filesystems and similar.</p>
<p>Introduced in version 2.9 </p>

</div>
</div>
<a class="anchor" id="ad4ec9c309072a92dd82ddb20efa4ab14"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* fuse_operations::flush)(const char *, struct <a class="el" href="structfuse__file__info.html">fuse_file_info</a> *)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Possibly flush cached data</p>
<p>BIG NOTE: This is not equivalent to <a class="el" href="structfuse__operations.html#a92bdd6f43ba390a54ac360541c56b528">fsync()</a>. It's not a request to sync dirty data.</p>
<p>Flush is called on each close() of a file descriptor. So if a filesystem wants to return write errors in close() and the file has cached dirty data, this is a good place to write back data and return any errors. Since many applications ignore close() errors this is not always useful.</p>
<p>NOTE: The <a class="el" href="structfuse__operations.html#ad4ec9c309072a92dd82ddb20efa4ab14">flush()</a> method may be called more than once for each <a class="el" href="structfuse__operations.html#a14b98c3f7ab97cc2ef8f9b1d9dc0709d">open()</a>. This happens if more than one file descriptor refers to an opened file due to dup(), dup2() or fork() calls. It is not possible to determine if a flush is final, so each flush should be treated equally. Multiple write-flush sequences are relatively rare, so this shouldn't be a problem.</p>
<p>Filesystems shouldn't assume that flush will always be called after some writes, or that if will be called at all.</p>
<p>Changed in version 2.2 </p>

</div>
</div>
<a class="anchor" id="a92bdd6f43ba390a54ac360541c56b528"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* fuse_operations::fsync)(const char *, int, struct <a class="el" href="structfuse__file__info.html">fuse_file_info</a> *)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Synchronize file contents</p>
<p>If the datasync parameter is non-zero, then only the user data should be flushed, not the meta data.</p>
<p>Changed in version 2.2 </p>

</div>
</div>
<a class="anchor" id="aba5cc1fe9a63ec152ceb19656f243256"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* fuse_operations::fsyncdir)(const char *, int, struct <a class="el" href="structfuse__file__info.html">fuse_file_info</a> *)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Synchronize directory contents</p>
<p>If the datasync parameter is non-zero, then only the user data should be flushed, not the meta data</p>
<p>Introduced in version 2.3 </p>

</div>
</div>
<a class="anchor" id="a1e492882859740f13cbf3344cf963c70"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* fuse_operations::ftruncate)(const char *, off_t, struct <a class="el" href="structfuse__file__info.html">fuse_file_info</a> *)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Change the size of an open file</p>
<p>This method is called instead of the <a class="el" href="structfuse__operations.html#a8efb50b9cd975ba8c4c450248caff6ed">truncate()</a> method if the truncation was invoked from an <a class="el" href="structfuse__operations.html#a1e492882859740f13cbf3344cf963c70">ftruncate()</a> system call.</p>
<p>If this method is not implemented or under Linux kernel versions earlier than 2.6.15, the <a class="el" href="structfuse__operations.html#a8efb50b9cd975ba8c4c450248caff6ed">truncate()</a> method will be called instead.</p>
<p>Introduced in version 2.5 </p>

</div>
</div>
<a class="anchor" id="a7a4c5d8eaf7179d819618c0cf3f73724"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* fuse_operations::getattr)(const char *, struct stat *)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get file attributes.</p>
<p>Similar to stat(). The 'st_dev' and 'st_blksize' fields are ignored. The 'st_ino' field is ignored except if the 'use_ino' mount option is given. </p>

</div>
</div>
<a class="anchor" id="ae21503c64fe2990c8a599f5ba339a8f2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* fuse_operations::getxattr)(const char *, const char *, char *, size_t)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get extended attributes </p>

</div>
</div>
<a class="anchor" id="adc6dc71274f185de72217e38d62142c4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void*(* fuse_operations::init)(struct <a class="el" href="structfuse__conn__info.html">fuse_conn_info</a> *conn)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initialize filesystem</p>
<p>The return value will passed in the private_data field of <a class="el" href="structfuse__context.html">fuse_context</a> to all file operations and as a parameter to the <a class="el" href="structfuse__operations.html#ac41d37ab860204fe4bd7612f9fb036c5">destroy()</a> method.</p>
<p>Introduced in version 2.3 Changed in version 2.6 </p>

</div>
</div>
<a class="anchor" id="a37f0612d67a6b76bf10fe6a71b0e3b5b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* fuse_operations::ioctl)(const char *, int cmd, void *arg, struct <a class="el" href="structfuse__file__info.html">fuse_file_info</a> *, unsigned int flags, void *data)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Ioctl</p>
<p>flags will have FUSE_IOCTL_COMPAT set for 32bit ioctls in 64bit environment. The size and direction of data is determined by <em>IOC</em>*() decoding of cmd. For _IOC_NONE, data will be NULL, for _IOC_WRITE data is out area, for _IOC_READ in area and if both are set in/out area. In all non-NULL cases, the area is of _IOC_SIZE(cmd) bytes.</p>
<p>If flags has FUSE_IOCTL_DIR then the <a class="el" href="structfuse__file__info.html">fuse_file_info</a> refers to a directory file handle.</p>
<p>Introduced in version 2.8 </p>

</div>
</div>
<a class="anchor" id="a1b234c43e826c6a690d80ea895a17f61"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* fuse_operations::link)(const char *, const char *)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a hard link to a file </p>

</div>
</div>
<a class="anchor" id="ab4a9c361ce48406f07d5a08ab03f5de8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* fuse_operations::listxattr)(const char *, char *, size_t)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>List extended attributes </p>

</div>
</div>
<a class="anchor" id="a1c3fff5cf0c1c2003d117e764b9a76fd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* fuse_operations::lock)(const char *, struct <a class="el" href="structfuse__file__info.html">fuse_file_info</a> *, int cmd, struct <a class="el" href="structfuse__operations.html#ad5968d566dab370974043fcf4271eb25">flock</a> *)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Perform POSIX file locking operation</p>
<p>The cmd argument will be either F_GETLK, F_SETLK or F_SETLKW.</p>
<p>For the meaning of fields in 'struct flock' see the man page for fcntl(2). The l_whence field will always be set to SEEK_SET.</p>
<p>For checking lock ownership, the 'fuse_file_info-&gt;owner' argument must be used.</p>
<p>For F_GETLK operation, the library will first check currently held locks, and if a conflicting lock is found it will return information without calling this method. This ensures, that for local locks the l_pid field is correctly filled in. The results may not be accurate in case of race conditions and in the presence of hard links, but it's unlikely that an application would rely on accurate GETLK results in these cases. If a conflicting lock is not found, this method will be called, and the filesystem may fill out l_pid by a meaningful value, or it may leave this field zero.</p>
<p>For F_SETLK and F_SETLKW the l_pid field will be set to the pid of the process performing the locking operation.</p>
<p>Note: if this method is not implemented, the kernel will still allow file locking to work locally. Hence it is only interesting for network filesystems and similar.</p>
<p>Introduced in version 2.6 </p>

</div>
</div>
<a class="anchor" id="a0a38aa6ca60e945772d5d21b0c1c8916"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* fuse_operations::mkdir)(const char *, mode_t)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a directory</p>
<p>Note that the mode argument may not have the type specification bits set, i.e. S_ISDIR(mode) can be false. To obtain the correct directory type bits use mode|S_IFDIR </p>

</div>
</div>
<a class="anchor" id="a1465eb2268cec2bb5ed11cb09bbda42f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* fuse_operations::mknod)(const char *, mode_t, dev_t)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a file node</p>
<p>This is called for creation of all non-directory, non-symlink nodes. If the filesystem defines a <a class="el" href="structfuse__operations.html#a97243e0f9268a96236bc3b6f2bacee17">create()</a> method, then for regular files that will be called instead. </p>

</div>
</div>
<a class="anchor" id="a14b98c3f7ab97cc2ef8f9b1d9dc0709d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* fuse_operations::open)(const char *, struct <a class="el" href="structfuse__file__info.html">fuse_file_info</a> *)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>File open operation</p>
<p>No creation (O_CREAT, O_EXCL) and by default also no truncation (O_TRUNC) flags will be passed to <a class="el" href="structfuse__operations.html#a14b98c3f7ab97cc2ef8f9b1d9dc0709d">open()</a>. If an application specifies O_TRUNC, fuse first calls <a class="el" href="structfuse__operations.html#a8efb50b9cd975ba8c4c450248caff6ed">truncate()</a> and then <a class="el" href="structfuse__operations.html#a14b98c3f7ab97cc2ef8f9b1d9dc0709d">open()</a>. Only if 'atomic_o_trunc' has been specified and kernel version is 2.6.24 or later, O_TRUNC is passed on to open.</p>
<p>Unless the 'default_permissions' mount option is given, open should check if the operation is permitted for the given flags. Optionally open may also return an arbitrary filehandle in the <a class="el" href="structfuse__file__info.html">fuse_file_info</a> structure, which will be passed to all file operations.</p>
<p>Changed in version 2.2 </p>

</div>
</div>
<a class="anchor" id="a1813889bc5e6e0087a936b7abe8b923f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* fuse_operations::opendir)(const char *, struct <a class="el" href="structfuse__file__info.html">fuse_file_info</a> *)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Open directory</p>
<p>Unless the 'default_permissions' mount option is given, this method should check if opendir is permitted for this directory. Optionally opendir may also return an arbitrary filehandle in the <a class="el" href="structfuse__file__info.html">fuse_file_info</a> structure, which will be passed to readdir, closedir and fsyncdir.</p>
<p>Introduced in version 2.3 </p>

</div>
</div>
<a class="anchor" id="a2c02838d30391c09dd5213edc61e106a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* fuse_operations::poll)(const char *, struct <a class="el" href="structfuse__file__info.html">fuse_file_info</a> *, struct fuse_pollhandle *ph, unsigned *reventsp)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Poll for IO readiness events</p>
<p>Note: If ph is non-NULL, the client should notify when IO readiness events occur by calling fuse_notify_poll() with the specified ph.</p>
<p>Regardless of the number of times poll with a non-NULL ph is received, single notification is enough to clear all. Notifying more times incurs overhead but doesn't harm correctness.</p>
<p>The callee is responsible for destroying ph with <a class="el" href="fuse__common_8h.html#adf5027f8a38b2efc03858efd7fdc756a">fuse_pollhandle_destroy()</a> when no longer in use.</p>
<p>Introduced in version 2.8 </p>

</div>
</div>
<a class="anchor" id="a2a1c6b4ce1845de56863f8b7939501b5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* fuse_operations::read)(const char *, char *, size_t, off_t, struct <a class="el" href="structfuse__file__info.html">fuse_file_info</a> *)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read data from an open file</p>
<p>Read should return exactly the number of bytes requested except on EOF or error, otherwise the rest of the data will be substituted with zeroes. An exception to this is when the 'direct_io' mount option is specified, in which case the return value of the read system call will reflect the return value of this operation.</p>
<p>Changed in version 2.2 </p>

</div>
</div>
<a class="anchor" id="a1ecbe844d937ffbbe135958bcb28a719"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* fuse_operations::read_buf)(const char *, struct <a class="el" href="structfuse__bufvec.html">fuse_bufvec</a> **bufp, size_t size, off_t off, struct <a class="el" href="structfuse__file__info.html">fuse_file_info</a> *)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Store data from an open file in a buffer</p>
<p>Similar to the <a class="el" href="structfuse__operations.html#a2a1c6b4ce1845de56863f8b7939501b5">read()</a> method, but data is stored and returned in a generic buffer.</p>
<p>No actual copying of data has to take place, the source file descriptor may simply be stored in the buffer for later data transfer.</p>
<p>The buffer must be allocated dynamically and stored at the location pointed to by bufp. If the buffer contains memory regions, they too must be allocated using malloc(). The allocated memory will be freed by the caller.</p>
<p>Introduced in version 2.9 </p>

</div>
</div>
<a class="anchor" id="a0f634deda31d1e1c42664585ae820076"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* fuse_operations::readdir)(const char *, void *, <a class="el" href="fuse_8h.html#ae2a2054f9852fd6020c26a1bcc7f1042">fuse_fill_dir_t</a>, off_t, struct <a class="el" href="structfuse__file__info.html">fuse_file_info</a> *)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read directory</p>
<p>This supersedes the old getdir() interface. New applications should use this.</p>
<p>The filesystem may choose between two modes of operation:</p>
<p>1) The readdir implementation ignores the offset parameter, and passes zero to the filler function's offset. The filler function will not return '1' (unless an error happens), so the whole directory is read in a single readdir operation. This works just like the old getdir() method.</p>
<p>2) The readdir implementation keeps track of the offsets of the directory entries. It uses the offset parameter and always passes non-zero offset to the filler function. When the buffer is full (or an error happens) the filler function will return '1'.</p>
<p>Introduced in version 2.3 </p>

</div>
</div>
<a class="anchor" id="ab4ce6e6d69dfde3ec550f22d932c5633"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* fuse_operations::readlink)(const char *, char *, size_t)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read the target of a symbolic link</p>
<p>The buffer should be filled with a null terminated string. The buffer size argument includes the space for the terminating null character. If the linkname is too long to fit in the buffer, it should be truncated. The return value should be 0 for success. </p>

</div>
</div>
<a class="anchor" id="abac8718cdfc1ee273a44831a27393419"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* fuse_operations::release)(const char *, struct <a class="el" href="structfuse__file__info.html">fuse_file_info</a> *)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Release an open file</p>
<p>Release is called when there are no more references to an open file: all file descriptors are closed and all memory mappings are unmapped.</p>
<p>For every <a class="el" href="structfuse__operations.html#a14b98c3f7ab97cc2ef8f9b1d9dc0709d">open()</a> call there will be exactly one <a class="el" href="structfuse__operations.html#abac8718cdfc1ee273a44831a27393419">release()</a> call with the same flags and file descriptor. It is possible to have a file opened more than once, in which case only the last release will mean, that no more reads/writes will happen on the file. The return value of release is ignored.</p>
<p>Changed in version 2.2 </p>

</div>
</div>
<a class="anchor" id="a729e53d36acc05a7a8985a1a3bbfac1e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* fuse_operations::releasedir)(const char *, struct <a class="el" href="structfuse__file__info.html">fuse_file_info</a> *)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Release directory</p>
<p>Introduced in version 2.3 </p>

</div>
</div>
<a class="anchor" id="a5e54de801a0e0d7019e4579112ecc477"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* fuse_operations::removexattr)(const char *, const char *)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Remove extended attributes </p>

</div>
</div>
<a class="anchor" id="aa777cbddc91887b117ac414e9a2d3cb5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* fuse_operations::rename)(const char *, const char *)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Rename a file </p>

</div>
</div>
<a class="anchor" id="ac59578d18db12f0142ae1ab6e8812d55"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* fuse_operations::rmdir)(const char *)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Remove a directory </p>

</div>
</div>
<a class="anchor" id="a988ced7091c2821daa208e6c96d8b598"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* fuse_operations::setxattr)(const char *, const char *, const char *, size_t, int)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set extended attributes </p>

</div>
</div>
<a class="anchor" id="a4e765e29122e7b6b533dc99849a52655"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* fuse_operations::statfs)(const char *, struct statvfs *)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get file system statistics</p>
<p>The 'f_frsize', 'f_favail', 'f_fsid' and 'f_flag' fields are ignored</p>
<p>Replaced 'struct statfs' parameter with 'struct statvfs' in version 2.5 </p>

</div>
</div>
<a class="anchor" id="ab86022391e56a8ad3211cf754b5b5ebe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* fuse_operations::symlink)(const char *, const char *)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a symbolic link </p>

</div>
</div>
<a class="anchor" id="a8efb50b9cd975ba8c4c450248caff6ed"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* fuse_operations::truncate)(const char *, off_t)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Change the size of a file </p>

</div>
</div>
<a class="anchor" id="a8bf63301a9d6e94311fa10480993801e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* fuse_operations::unlink)(const char *)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Remove a file </p>

</div>
</div>
<a class="anchor" id="acb7452acad1002d418409892b6e54c2e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* fuse_operations::utime)(const char *, struct utimbuf *)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Change the access and/or modification times of a file</p>
<p>Deprecated, use <a class="el" href="structfuse__operations.html#a79955861cc5eb006954476607ef28944">utimens()</a> instead. </p>

</div>
</div>
<a class="anchor" id="a79955861cc5eb006954476607ef28944"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* fuse_operations::utimens)(const char *, const struct timespec tv[2])</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Change the access and modification times of a file with nanosecond resolution</p>
<p>This supersedes the old <a class="el" href="structfuse__operations.html#acb7452acad1002d418409892b6e54c2e">utime()</a> interface. New applications should use this.</p>
<p>See the utimensat(2) man page for details.</p>
<p>Introduced in version 2.6 </p>

</div>
</div>
<a class="anchor" id="a897d1ece4b8b04c92d97b97b2dbf9768"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* fuse_operations::write)(const char *, const char *, size_t, off_t, struct <a class="el" href="structfuse__file__info.html">fuse_file_info</a> *)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Write data to an open file</p>
<p>Write should return exactly the number of bytes requested except on error. An exception to this is when the 'direct_io' mount option is specified (see read operation).</p>
<p>Changed in version 2.2 </p>

</div>
</div>
<a class="anchor" id="a89f400083a03ddcc43e47ce126b6761f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* fuse_operations::write_buf)(const char *, struct <a class="el" href="structfuse__bufvec.html">fuse_bufvec</a> *buf, off_t off, struct <a class="el" href="structfuse__file__info.html">fuse_file_info</a> *)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Write contents of buffer to an open file</p>
<p>Similar to the <a class="el" href="structfuse__operations.html#a897d1ece4b8b04c92d97b97b2dbf9768">write()</a> method, but data is supplied in a generic buffer. Use <a class="el" href="fuse__common_8h.html#a9ca301390fb5e85b85153abb1891a3f7">fuse_buf_copy()</a> to transfer data to the destination.</p>
<p>Introduced in version 2.9 </p>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li>include/<a class="el" href="fuse_8h.html">fuse.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sat Apr 23 2016 09:43:20 for fuse by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.8
</small></address>
</body>
</html>
