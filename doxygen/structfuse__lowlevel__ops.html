<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.8"/>
<title>fuse: fuse_lowlevel_ops Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">fuse
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.8 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="functions.html"><span>Data&#160;Fields</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-attribs">Data Fields</a>  </div>
  <div class="headertitle">
<div class="title">fuse_lowlevel_ops Struct Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;fuse_lowlevel.h&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Data Fields</h2></td></tr>
<tr class="memitem:ab6fa0b9edb5b002cd1502c969c887329"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfuse__lowlevel__ops.html#ab6fa0b9edb5b002cd1502c969c887329">init</a> )(void *userdata, struct <a class="el" href="structfuse__conn__info.html">fuse_conn_info</a> *conn)</td></tr>
<tr class="separator:ab6fa0b9edb5b002cd1502c969c887329"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a963181c33f58859fd060b0ccde2f5ec3"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfuse__lowlevel__ops.html#a963181c33f58859fd060b0ccde2f5ec3">destroy</a> )(void *userdata)</td></tr>
<tr class="separator:a963181c33f58859fd060b0ccde2f5ec3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8a2850c71bec355ad347413fa73f7c2"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfuse__lowlevel__ops.html#ae8a2850c71bec355ad347413fa73f7c2">lookup</a> )(<a class="el" href="fuse__lowlevel_8h.html#a33e2aa4a8905a05397292ae047cd2257">fuse_req_t</a> req, <a class="el" href="fuse__lowlevel_8h.html#ab419149c707451eaf61b75afb852e016">fuse_ino_t</a> parent, const char *name)</td></tr>
<tr class="separator:ae8a2850c71bec355ad347413fa73f7c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a9112cb58497e68b7b197951c059d1e"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfuse__lowlevel__ops.html#a5a9112cb58497e68b7b197951c059d1e">forget</a> )(<a class="el" href="fuse__lowlevel_8h.html#a33e2aa4a8905a05397292ae047cd2257">fuse_req_t</a> req, <a class="el" href="fuse__lowlevel_8h.html#ab419149c707451eaf61b75afb852e016">fuse_ino_t</a> ino, unsigned long nlookup)</td></tr>
<tr class="separator:a5a9112cb58497e68b7b197951c059d1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a994c316fa7a1ca33525a4540675f6b47"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfuse__lowlevel__ops.html#a994c316fa7a1ca33525a4540675f6b47">getattr</a> )(<a class="el" href="fuse__lowlevel_8h.html#a33e2aa4a8905a05397292ae047cd2257">fuse_req_t</a> req, <a class="el" href="fuse__lowlevel_8h.html#ab419149c707451eaf61b75afb852e016">fuse_ino_t</a> ino, struct <a class="el" href="structfuse__file__info.html">fuse_file_info</a> *fi)</td></tr>
<tr class="separator:a994c316fa7a1ca33525a4540675f6b47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a95408dd79575df7f6c64e55f1e973b"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfuse__lowlevel__ops.html#a6a95408dd79575df7f6c64e55f1e973b">setattr</a> )(<a class="el" href="fuse__lowlevel_8h.html#a33e2aa4a8905a05397292ae047cd2257">fuse_req_t</a> req, <a class="el" href="fuse__lowlevel_8h.html#ab419149c707451eaf61b75afb852e016">fuse_ino_t</a> ino, struct stat *attr, int to_set, struct <a class="el" href="structfuse__file__info.html">fuse_file_info</a> *fi)</td></tr>
<tr class="separator:a6a95408dd79575df7f6c64e55f1e973b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1032649069ae28d46bde76a40743fcf"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfuse__lowlevel__ops.html#ae1032649069ae28d46bde76a40743fcf">readlink</a> )(<a class="el" href="fuse__lowlevel_8h.html#a33e2aa4a8905a05397292ae047cd2257">fuse_req_t</a> req, <a class="el" href="fuse__lowlevel_8h.html#ab419149c707451eaf61b75afb852e016">fuse_ino_t</a> ino)</td></tr>
<tr class="separator:ae1032649069ae28d46bde76a40743fcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cd44aa96291fa366d4ef40e2d1d1d76"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfuse__lowlevel__ops.html#a5cd44aa96291fa366d4ef40e2d1d1d76">mknod</a> )(<a class="el" href="fuse__lowlevel_8h.html#a33e2aa4a8905a05397292ae047cd2257">fuse_req_t</a> req, <a class="el" href="fuse__lowlevel_8h.html#ab419149c707451eaf61b75afb852e016">fuse_ino_t</a> parent, const char *name, mode_t mode, dev_t rdev)</td></tr>
<tr class="separator:a5cd44aa96291fa366d4ef40e2d1d1d76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23af0f6683447112848d9f1731e021d7"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfuse__lowlevel__ops.html#a23af0f6683447112848d9f1731e021d7">mkdir</a> )(<a class="el" href="fuse__lowlevel_8h.html#a33e2aa4a8905a05397292ae047cd2257">fuse_req_t</a> req, <a class="el" href="fuse__lowlevel_8h.html#ab419149c707451eaf61b75afb852e016">fuse_ino_t</a> parent, const char *name, mode_t mode)</td></tr>
<tr class="separator:a23af0f6683447112848d9f1731e021d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb6e186f5cbe806d3838a51c112a97ee"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfuse__lowlevel__ops.html#afb6e186f5cbe806d3838a51c112a97ee">unlink</a> )(<a class="el" href="fuse__lowlevel_8h.html#a33e2aa4a8905a05397292ae047cd2257">fuse_req_t</a> req, <a class="el" href="fuse__lowlevel_8h.html#ab419149c707451eaf61b75afb852e016">fuse_ino_t</a> parent, const char *name)</td></tr>
<tr class="separator:afb6e186f5cbe806d3838a51c112a97ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cbf1eaf4366aed47fa5d991ea5ff0d5"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfuse__lowlevel__ops.html#a3cbf1eaf4366aed47fa5d991ea5ff0d5">rmdir</a> )(<a class="el" href="fuse__lowlevel_8h.html#a33e2aa4a8905a05397292ae047cd2257">fuse_req_t</a> req, <a class="el" href="fuse__lowlevel_8h.html#ab419149c707451eaf61b75afb852e016">fuse_ino_t</a> parent, const char *name)</td></tr>
<tr class="separator:a3cbf1eaf4366aed47fa5d991ea5ff0d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30455cc58397c5a45434492d93a71af4"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfuse__lowlevel__ops.html#a30455cc58397c5a45434492d93a71af4">symlink</a> )(<a class="el" href="fuse__lowlevel_8h.html#a33e2aa4a8905a05397292ae047cd2257">fuse_req_t</a> req, const char *<a class="el" href="structfuse__lowlevel__ops.html#a406798b81f44a8b54f188455c31b9be8">link</a>, <a class="el" href="fuse__lowlevel_8h.html#ab419149c707451eaf61b75afb852e016">fuse_ino_t</a> parent, const char *name)</td></tr>
<tr class="separator:a30455cc58397c5a45434492d93a71af4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff3670fecb2b4bf45543c191c9d70c02"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfuse__lowlevel__ops.html#aff3670fecb2b4bf45543c191c9d70c02">rename</a> )(<a class="el" href="fuse__lowlevel_8h.html#a33e2aa4a8905a05397292ae047cd2257">fuse_req_t</a> req, <a class="el" href="fuse__lowlevel_8h.html#ab419149c707451eaf61b75afb852e016">fuse_ino_t</a> parent, const char *name, <a class="el" href="fuse__lowlevel_8h.html#ab419149c707451eaf61b75afb852e016">fuse_ino_t</a> newparent, const char *newname)</td></tr>
<tr class="separator:aff3670fecb2b4bf45543c191c9d70c02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a406798b81f44a8b54f188455c31b9be8"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfuse__lowlevel__ops.html#a406798b81f44a8b54f188455c31b9be8">link</a> )(<a class="el" href="fuse__lowlevel_8h.html#a33e2aa4a8905a05397292ae047cd2257">fuse_req_t</a> req, <a class="el" href="fuse__lowlevel_8h.html#ab419149c707451eaf61b75afb852e016">fuse_ino_t</a> ino, <a class="el" href="fuse__lowlevel_8h.html#ab419149c707451eaf61b75afb852e016">fuse_ino_t</a> newparent, const char *newname)</td></tr>
<tr class="separator:a406798b81f44a8b54f188455c31b9be8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab2f5186ecaa817e75ed443165288218"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfuse__lowlevel__ops.html#aab2f5186ecaa817e75ed443165288218">open</a> )(<a class="el" href="fuse__lowlevel_8h.html#a33e2aa4a8905a05397292ae047cd2257">fuse_req_t</a> req, <a class="el" href="fuse__lowlevel_8h.html#ab419149c707451eaf61b75afb852e016">fuse_ino_t</a> ino, struct <a class="el" href="structfuse__file__info.html">fuse_file_info</a> *fi)</td></tr>
<tr class="separator:aab2f5186ecaa817e75ed443165288218"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7b740dccdc6ddc388cdcd7897e4c2e3"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfuse__lowlevel__ops.html#ab7b740dccdc6ddc388cdcd7897e4c2e3">read</a> )(<a class="el" href="fuse__lowlevel_8h.html#a33e2aa4a8905a05397292ae047cd2257">fuse_req_t</a> req, <a class="el" href="fuse__lowlevel_8h.html#ab419149c707451eaf61b75afb852e016">fuse_ino_t</a> ino, size_t size, off_t off, struct <a class="el" href="structfuse__file__info.html">fuse_file_info</a> *fi)</td></tr>
<tr class="separator:ab7b740dccdc6ddc388cdcd7897e4c2e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09cc5c1078cfb909513b5ca27464f53a"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfuse__lowlevel__ops.html#a09cc5c1078cfb909513b5ca27464f53a">write</a> )(<a class="el" href="fuse__lowlevel_8h.html#a33e2aa4a8905a05397292ae047cd2257">fuse_req_t</a> req, <a class="el" href="fuse__lowlevel_8h.html#ab419149c707451eaf61b75afb852e016">fuse_ino_t</a> ino, const char *buf, size_t size, off_t off, struct <a class="el" href="structfuse__file__info.html">fuse_file_info</a> *fi)</td></tr>
<tr class="separator:a09cc5c1078cfb909513b5ca27464f53a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6c2540969d60626f1c18e0012de393a"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfuse__lowlevel__ops.html#af6c2540969d60626f1c18e0012de393a">flush</a> )(<a class="el" href="fuse__lowlevel_8h.html#a33e2aa4a8905a05397292ae047cd2257">fuse_req_t</a> req, <a class="el" href="fuse__lowlevel_8h.html#ab419149c707451eaf61b75afb852e016">fuse_ino_t</a> ino, struct <a class="el" href="structfuse__file__info.html">fuse_file_info</a> *fi)</td></tr>
<tr class="separator:af6c2540969d60626f1c18e0012de393a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc49c6310cd0eaddf116988426ca21d2"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfuse__lowlevel__ops.html#abc49c6310cd0eaddf116988426ca21d2">release</a> )(<a class="el" href="fuse__lowlevel_8h.html#a33e2aa4a8905a05397292ae047cd2257">fuse_req_t</a> req, <a class="el" href="fuse__lowlevel_8h.html#ab419149c707451eaf61b75afb852e016">fuse_ino_t</a> ino, struct <a class="el" href="structfuse__file__info.html">fuse_file_info</a> *fi)</td></tr>
<tr class="separator:abc49c6310cd0eaddf116988426ca21d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81ff5a93a2edd71b063c2e827e0fd8d8"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfuse__lowlevel__ops.html#a81ff5a93a2edd71b063c2e827e0fd8d8">fsync</a> )(<a class="el" href="fuse__lowlevel_8h.html#a33e2aa4a8905a05397292ae047cd2257">fuse_req_t</a> req, <a class="el" href="fuse__lowlevel_8h.html#ab419149c707451eaf61b75afb852e016">fuse_ino_t</a> ino, int datasync, struct <a class="el" href="structfuse__file__info.html">fuse_file_info</a> *fi)</td></tr>
<tr class="separator:a81ff5a93a2edd71b063c2e827e0fd8d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57a2c2d826fe11dd005d3275c3028d5e"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfuse__lowlevel__ops.html#a57a2c2d826fe11dd005d3275c3028d5e">opendir</a> )(<a class="el" href="fuse__lowlevel_8h.html#a33e2aa4a8905a05397292ae047cd2257">fuse_req_t</a> req, <a class="el" href="fuse__lowlevel_8h.html#ab419149c707451eaf61b75afb852e016">fuse_ino_t</a> ino, struct <a class="el" href="structfuse__file__info.html">fuse_file_info</a> *fi)</td></tr>
<tr class="separator:a57a2c2d826fe11dd005d3275c3028d5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1ef8e59e0cb0b02dc0e406898aeaa51"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfuse__lowlevel__ops.html#af1ef8e59e0cb0b02dc0e406898aeaa51">readdir</a> )(<a class="el" href="fuse__lowlevel_8h.html#a33e2aa4a8905a05397292ae047cd2257">fuse_req_t</a> req, <a class="el" href="fuse__lowlevel_8h.html#ab419149c707451eaf61b75afb852e016">fuse_ino_t</a> ino, size_t size, off_t off, struct <a class="el" href="structfuse__file__info.html">fuse_file_info</a> *fi)</td></tr>
<tr class="separator:af1ef8e59e0cb0b02dc0e406898aeaa51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfc54ffe5fa5778fc273a6666494d802"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfuse__lowlevel__ops.html#abfc54ffe5fa5778fc273a6666494d802">releasedir</a> )(<a class="el" href="fuse__lowlevel_8h.html#a33e2aa4a8905a05397292ae047cd2257">fuse_req_t</a> req, <a class="el" href="fuse__lowlevel_8h.html#ab419149c707451eaf61b75afb852e016">fuse_ino_t</a> ino, struct <a class="el" href="structfuse__file__info.html">fuse_file_info</a> *fi)</td></tr>
<tr class="separator:abfc54ffe5fa5778fc273a6666494d802"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2e3a9ad8b264daec4c254f5b064dfb3"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfuse__lowlevel__ops.html#ab2e3a9ad8b264daec4c254f5b064dfb3">fsyncdir</a> )(<a class="el" href="fuse__lowlevel_8h.html#a33e2aa4a8905a05397292ae047cd2257">fuse_req_t</a> req, <a class="el" href="fuse__lowlevel_8h.html#ab419149c707451eaf61b75afb852e016">fuse_ino_t</a> ino, int datasync, struct <a class="el" href="structfuse__file__info.html">fuse_file_info</a> *fi)</td></tr>
<tr class="separator:ab2e3a9ad8b264daec4c254f5b064dfb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeea156121a28b519e284451721fb7d25"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfuse__lowlevel__ops.html#aeea156121a28b519e284451721fb7d25">statfs</a> )(<a class="el" href="fuse__lowlevel_8h.html#a33e2aa4a8905a05397292ae047cd2257">fuse_req_t</a> req, <a class="el" href="fuse__lowlevel_8h.html#ab419149c707451eaf61b75afb852e016">fuse_ino_t</a> ino)</td></tr>
<tr class="separator:aeea156121a28b519e284451721fb7d25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab80c4081204c07a423c3c88b116f3086"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfuse__lowlevel__ops.html#ab80c4081204c07a423c3c88b116f3086">setxattr</a> )(<a class="el" href="fuse__lowlevel_8h.html#a33e2aa4a8905a05397292ae047cd2257">fuse_req_t</a> req, <a class="el" href="fuse__lowlevel_8h.html#ab419149c707451eaf61b75afb852e016">fuse_ino_t</a> ino, const char *name, const char *value, size_t size, int flags)</td></tr>
<tr class="separator:ab80c4081204c07a423c3c88b116f3086"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaed65c2801391c35ad0c60e73a0c43d9"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfuse__lowlevel__ops.html#aaed65c2801391c35ad0c60e73a0c43d9">getxattr</a> )(<a class="el" href="fuse__lowlevel_8h.html#a33e2aa4a8905a05397292ae047cd2257">fuse_req_t</a> req, <a class="el" href="fuse__lowlevel_8h.html#ab419149c707451eaf61b75afb852e016">fuse_ino_t</a> ino, const char *name, size_t size)</td></tr>
<tr class="separator:aaed65c2801391c35ad0c60e73a0c43d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f084e779f3fbd407bb5d0890bf0ef6b"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfuse__lowlevel__ops.html#a0f084e779f3fbd407bb5d0890bf0ef6b">listxattr</a> )(<a class="el" href="fuse__lowlevel_8h.html#a33e2aa4a8905a05397292ae047cd2257">fuse_req_t</a> req, <a class="el" href="fuse__lowlevel_8h.html#ab419149c707451eaf61b75afb852e016">fuse_ino_t</a> ino, size_t size)</td></tr>
<tr class="separator:a0f084e779f3fbd407bb5d0890bf0ef6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15be6632986e6be8660071e1d71ffe51"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfuse__lowlevel__ops.html#a15be6632986e6be8660071e1d71ffe51">removexattr</a> )(<a class="el" href="fuse__lowlevel_8h.html#a33e2aa4a8905a05397292ae047cd2257">fuse_req_t</a> req, <a class="el" href="fuse__lowlevel_8h.html#ab419149c707451eaf61b75afb852e016">fuse_ino_t</a> ino, const char *name)</td></tr>
<tr class="separator:a15be6632986e6be8660071e1d71ffe51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdfcb8249b126f95bc33ba23e78f1916"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfuse__lowlevel__ops.html#abdfcb8249b126f95bc33ba23e78f1916">access</a> )(<a class="el" href="fuse__lowlevel_8h.html#a33e2aa4a8905a05397292ae047cd2257">fuse_req_t</a> req, <a class="el" href="fuse__lowlevel_8h.html#ab419149c707451eaf61b75afb852e016">fuse_ino_t</a> ino, int mask)</td></tr>
<tr class="separator:abdfcb8249b126f95bc33ba23e78f1916"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a226ce8b472150dd91977cb6c191ff792"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfuse__lowlevel__ops.html#a226ce8b472150dd91977cb6c191ff792">create</a> )(<a class="el" href="fuse__lowlevel_8h.html#a33e2aa4a8905a05397292ae047cd2257">fuse_req_t</a> req, <a class="el" href="fuse__lowlevel_8h.html#ab419149c707451eaf61b75afb852e016">fuse_ino_t</a> parent, const char *name, mode_t mode, struct <a class="el" href="structfuse__file__info.html">fuse_file_info</a> *fi)</td></tr>
<tr class="separator:a226ce8b472150dd91977cb6c191ff792"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a709d41ca0cde37dbd4d4d06c89f6906a"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfuse__lowlevel__ops.html#a709d41ca0cde37dbd4d4d06c89f6906a">getlk</a> )(<a class="el" href="fuse__lowlevel_8h.html#a33e2aa4a8905a05397292ae047cd2257">fuse_req_t</a> req, <a class="el" href="fuse__lowlevel_8h.html#ab419149c707451eaf61b75afb852e016">fuse_ino_t</a> ino, struct <a class="el" href="structfuse__file__info.html">fuse_file_info</a> *fi, struct <a class="el" href="structfuse__lowlevel__ops.html#a01b103e34d751d0456add93d9c34e711">flock</a> *lock)</td></tr>
<tr class="separator:a709d41ca0cde37dbd4d4d06c89f6906a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af290d78441583d1d6ba02da01904f328"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfuse__lowlevel__ops.html#af290d78441583d1d6ba02da01904f328">setlk</a> )(<a class="el" href="fuse__lowlevel_8h.html#a33e2aa4a8905a05397292ae047cd2257">fuse_req_t</a> req, <a class="el" href="fuse__lowlevel_8h.html#ab419149c707451eaf61b75afb852e016">fuse_ino_t</a> ino, struct <a class="el" href="structfuse__file__info.html">fuse_file_info</a> *fi, struct <a class="el" href="structfuse__lowlevel__ops.html#a01b103e34d751d0456add93d9c34e711">flock</a> *lock, int sleep)</td></tr>
<tr class="separator:af290d78441583d1d6ba02da01904f328"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb295e706897d7ada3249d8b027fde7b"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfuse__lowlevel__ops.html#adb295e706897d7ada3249d8b027fde7b">bmap</a> )(<a class="el" href="fuse__lowlevel_8h.html#a33e2aa4a8905a05397292ae047cd2257">fuse_req_t</a> req, <a class="el" href="fuse__lowlevel_8h.html#ab419149c707451eaf61b75afb852e016">fuse_ino_t</a> ino, size_t blocksize, uint64_t idx)</td></tr>
<tr class="separator:adb295e706897d7ada3249d8b027fde7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a399da4f164985be5f5b93ef5b33551da"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfuse__lowlevel__ops.html#a399da4f164985be5f5b93ef5b33551da">ioctl</a> )(<a class="el" href="fuse__lowlevel_8h.html#a33e2aa4a8905a05397292ae047cd2257">fuse_req_t</a> req, <a class="el" href="fuse__lowlevel_8h.html#ab419149c707451eaf61b75afb852e016">fuse_ino_t</a> ino, int cmd, void *arg, struct <a class="el" href="structfuse__file__info.html">fuse_file_info</a> *fi, unsigned flags, const void *in_buf, size_t in_bufsz, size_t out_bufsz)</td></tr>
<tr class="separator:a399da4f164985be5f5b93ef5b33551da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50abf8a54b6c73a5a40123b6cf63c71e"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfuse__lowlevel__ops.html#a50abf8a54b6c73a5a40123b6cf63c71e">poll</a> )(<a class="el" href="fuse__lowlevel_8h.html#a33e2aa4a8905a05397292ae047cd2257">fuse_req_t</a> req, <a class="el" href="fuse__lowlevel_8h.html#ab419149c707451eaf61b75afb852e016">fuse_ino_t</a> ino, struct <a class="el" href="structfuse__file__info.html">fuse_file_info</a> *fi, struct fuse_pollhandle *ph)</td></tr>
<tr class="separator:a50abf8a54b6c73a5a40123b6cf63c71e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b40ed06d1297f244363a8dcd40d44aa"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfuse__lowlevel__ops.html#a3b40ed06d1297f244363a8dcd40d44aa">write_buf</a> )(<a class="el" href="fuse__lowlevel_8h.html#a33e2aa4a8905a05397292ae047cd2257">fuse_req_t</a> req, <a class="el" href="fuse__lowlevel_8h.html#ab419149c707451eaf61b75afb852e016">fuse_ino_t</a> ino, struct <a class="el" href="structfuse__bufvec.html">fuse_bufvec</a> *bufv, off_t off, struct <a class="el" href="structfuse__file__info.html">fuse_file_info</a> *fi)</td></tr>
<tr class="separator:a3b40ed06d1297f244363a8dcd40d44aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c1d7ad0c1fb40d7180660e7f3f7f089"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfuse__lowlevel__ops.html#a1c1d7ad0c1fb40d7180660e7f3f7f089">retrieve_reply</a> )(<a class="el" href="fuse__lowlevel_8h.html#a33e2aa4a8905a05397292ae047cd2257">fuse_req_t</a> req, void *cookie, <a class="el" href="fuse__lowlevel_8h.html#ab419149c707451eaf61b75afb852e016">fuse_ino_t</a> ino, off_t offset, struct <a class="el" href="structfuse__bufvec.html">fuse_bufvec</a> *bufv)</td></tr>
<tr class="separator:a1c1d7ad0c1fb40d7180660e7f3f7f089"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17808183820bb58dcc17db639511a2cb"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfuse__lowlevel__ops.html#a17808183820bb58dcc17db639511a2cb">forget_multi</a> )(<a class="el" href="fuse__lowlevel_8h.html#a33e2aa4a8905a05397292ae047cd2257">fuse_req_t</a> req, size_t count, struct fuse_forget_data *forgets)</td></tr>
<tr class="separator:a17808183820bb58dcc17db639511a2cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01b103e34d751d0456add93d9c34e711"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfuse__lowlevel__ops.html#a01b103e34d751d0456add93d9c34e711">flock</a> )(<a class="el" href="fuse__lowlevel_8h.html#a33e2aa4a8905a05397292ae047cd2257">fuse_req_t</a> req, <a class="el" href="fuse__lowlevel_8h.html#ab419149c707451eaf61b75afb852e016">fuse_ino_t</a> ino, struct <a class="el" href="structfuse__file__info.html">fuse_file_info</a> *fi, int op)</td></tr>
<tr class="separator:a01b103e34d751d0456add93d9c34e711"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d0ddef3583d645ccf957bdef9291047"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfuse__lowlevel__ops.html#a5d0ddef3583d645ccf957bdef9291047">fallocate</a> )(<a class="el" href="fuse__lowlevel_8h.html#a33e2aa4a8905a05397292ae047cd2257">fuse_req_t</a> req, <a class="el" href="fuse__lowlevel_8h.html#ab419149c707451eaf61b75afb852e016">fuse_ino_t</a> ino, int mode, off_t offset, off_t length, struct <a class="el" href="structfuse__file__info.html">fuse_file_info</a> *fi)</td></tr>
<tr class="separator:a5d0ddef3583d645ccf957bdef9291047"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Low level filesystem operations</p>
<p>Most of the methods (with the exception of init and destroy) receive a request handle (fuse_req_t) as their first argument. This handle must be passed to one of the specified reply functions.</p>
<p>This may be done inside the method invocation, or after the call has returned. The request handle is valid until one of the reply functions is called.</p>
<p>Other pointer arguments (name, <a class="el" href="structfuse__file__info.html">fuse_file_info</a>, etc) are not valid after the call has returned, so if they are needed later, their contents have to be copied.</p>
<p>The filesystem sometimes needs to handle a return value of -ENOENT from the reply function, which means, that the request was interrupted, and the reply discarded. For example if <a class="el" href="fuse__lowlevel_8h.html#a170f8c6b953d70928e83bcecee43bfdc">fuse_reply_open()</a> return -ENOENT means, that the release method for this file will not be called. </p>
</div><h2 class="groupheader">Field Documentation</h2>
<a class="anchor" id="abdfcb8249b126f95bc33ba23e78f1916"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* fuse_lowlevel_ops::access)(<a class="el" href="fuse__lowlevel_8h.html#a33e2aa4a8905a05397292ae047cd2257">fuse_req_t</a> req, <a class="el" href="fuse__lowlevel_8h.html#ab419149c707451eaf61b75afb852e016">fuse_ino_t</a> ino, int mask)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check file access permissions</p>
<p>This will be called for the <a class="el" href="structfuse__lowlevel__ops.html#abdfcb8249b126f95bc33ba23e78f1916">access()</a> system call. If the 'default_permissions' mount option is given, this method is not called.</p>
<p>This method is not called under Linux kernel versions 2.4.x</p>
<p>Introduced in version 2.5</p>
<p>Valid replies: fuse_reply_err</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">req</td><td>request handle </td></tr>
    <tr><td class="paramname">ino</td><td>the inode number </td></tr>
    <tr><td class="paramname">mask</td><td>requested access mode </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="adb295e706897d7ada3249d8b027fde7b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* fuse_lowlevel_ops::bmap)(<a class="el" href="fuse__lowlevel_8h.html#a33e2aa4a8905a05397292ae047cd2257">fuse_req_t</a> req, <a class="el" href="fuse__lowlevel_8h.html#ab419149c707451eaf61b75afb852e016">fuse_ino_t</a> ino, size_t blocksize, uint64_t idx)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Map block index within file to block index within device</p>
<p>Note: This makes sense only for block device backed filesystems mounted with the 'blkdev' option</p>
<p>Introduced in version 2.6</p>
<p>Valid replies: fuse_reply_bmap fuse_reply_err</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">req</td><td>request handle </td></tr>
    <tr><td class="paramname">ino</td><td>the inode number </td></tr>
    <tr><td class="paramname">blocksize</td><td>unit of block index </td></tr>
    <tr><td class="paramname">idx</td><td>block index within file </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a226ce8b472150dd91977cb6c191ff792"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* fuse_lowlevel_ops::create)(<a class="el" href="fuse__lowlevel_8h.html#a33e2aa4a8905a05397292ae047cd2257">fuse_req_t</a> req, <a class="el" href="fuse__lowlevel_8h.html#ab419149c707451eaf61b75afb852e016">fuse_ino_t</a> parent, const char *name, mode_t mode, struct <a class="el" href="structfuse__file__info.html">fuse_file_info</a> *fi)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create and open a file</p>
<p>If the file does not exist, first create it with the specified mode, and then open it.</p>
<p>Open flags (with the exception of O_NOCTTY) are available in fi-&gt;flags.</p>
<p>Filesystem may store an arbitrary file handle (pointer, index, etc) in fi-&gt;fh, and use this in other all other file operations (read, write, flush, release, fsync).</p>
<p>There are also some flags (direct_io, keep_cache) which the filesystem may set in fi, to change the way the file is opened. See <a class="el" href="structfuse__file__info.html">fuse_file_info</a> structure in &lt;<a class="el" href="fuse__common_8h.html">fuse_common.h</a>&gt; for more details.</p>
<p>If this method is not implemented or under Linux kernel versions earlier than 2.6.15, the <a class="el" href="structfuse__lowlevel__ops.html#a5cd44aa96291fa366d4ef40e2d1d1d76">mknod()</a> and <a class="el" href="structfuse__lowlevel__ops.html#aab2f5186ecaa817e75ed443165288218">open()</a> methods will be called instead.</p>
<p>Introduced in version 2.5</p>
<p>Valid replies: fuse_reply_create fuse_reply_err</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">req</td><td>request handle </td></tr>
    <tr><td class="paramname">parent</td><td>inode number of the parent directory </td></tr>
    <tr><td class="paramname">name</td><td>to create </td></tr>
    <tr><td class="paramname">mode</td><td>file type and mode with which to create the new file </td></tr>
    <tr><td class="paramname">fi</td><td>file information </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a963181c33f58859fd060b0ccde2f5ec3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* fuse_lowlevel_ops::destroy)(void *userdata)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Clean up filesystem</p>
<p>Called on filesystem exit</p>
<p>There's no reply to this function</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">userdata</td><td>the user data passed to <a class="el" href="fuse__lowlevel_8h.html#ab71e91777def283987cd8a504e926d01">fuse_lowlevel_new()</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5d0ddef3583d645ccf957bdef9291047"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* fuse_lowlevel_ops::fallocate)(<a class="el" href="fuse__lowlevel_8h.html#a33e2aa4a8905a05397292ae047cd2257">fuse_req_t</a> req, <a class="el" href="fuse__lowlevel_8h.html#ab419149c707451eaf61b75afb852e016">fuse_ino_t</a> ino, int mode, off_t offset, off_t length, struct <a class="el" href="structfuse__file__info.html">fuse_file_info</a> *fi)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Allocate requested space. If this function returns success then subsequent writes to the specified range shall not fail due to the lack of free space on the file system storage media.</p>
<p>Introduced in version 2.9</p>
<p>Valid replies: fuse_reply_err</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">req</td><td>request handle </td></tr>
    <tr><td class="paramname">ino</td><td>the inode number </td></tr>
    <tr><td class="paramname">offset</td><td>starting point for allocated region </td></tr>
    <tr><td class="paramname">length</td><td>size of allocated region </td></tr>
    <tr><td class="paramname">mode</td><td>determines the operation to be performed on the given range, see fallocate(2) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a01b103e34d751d0456add93d9c34e711"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* fuse_lowlevel_ops::flock)(<a class="el" href="fuse__lowlevel_8h.html#a33e2aa4a8905a05397292ae047cd2257">fuse_req_t</a> req, <a class="el" href="fuse__lowlevel_8h.html#ab419149c707451eaf61b75afb852e016">fuse_ino_t</a> ino, struct <a class="el" href="structfuse__file__info.html">fuse_file_info</a> *fi, int op)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Acquire, modify or release a BSD file lock</p>
<p>Note: if the locking methods are not implemented, the kernel will still allow file locking to work locally. Hence these are only interesting for network filesystems and similar.</p>
<p>Introduced in version 2.9</p>
<p>Valid replies: fuse_reply_err</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">req</td><td>request handle </td></tr>
    <tr><td class="paramname">ino</td><td>the inode number </td></tr>
    <tr><td class="paramname">fi</td><td>file information </td></tr>
    <tr><td class="paramname">op</td><td>the locking operation, see flock(2) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af6c2540969d60626f1c18e0012de393a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* fuse_lowlevel_ops::flush)(<a class="el" href="fuse__lowlevel_8h.html#a33e2aa4a8905a05397292ae047cd2257">fuse_req_t</a> req, <a class="el" href="fuse__lowlevel_8h.html#ab419149c707451eaf61b75afb852e016">fuse_ino_t</a> ino, struct <a class="el" href="structfuse__file__info.html">fuse_file_info</a> *fi)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Flush method</p>
<p>This is called on each close() of the opened file.</p>
<p>Since file descriptors can be duplicated (dup, dup2, fork), for one open call there may be many flush calls.</p>
<p>Filesystems shouldn't assume that flush will always be called after some writes, or that if will be called at all.</p>
<p>fi-&gt;fh will contain the value set by the open method, or will be undefined if the open method didn't set any value.</p>
<p>NOTE: the name of the method is misleading, since (unlike fsync) the filesystem is not forced to flush pending writes. One reason to flush data, is if the filesystem wants to return write errors.</p>
<p>If the filesystem supports file locking operations (setlk, getlk) it should remove all locks belonging to 'fi-&gt;owner'.</p>
<p>Valid replies: fuse_reply_err</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">req</td><td>request handle </td></tr>
    <tr><td class="paramname">ino</td><td>the inode number </td></tr>
    <tr><td class="paramname">fi</td><td>file information </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5a9112cb58497e68b7b197951c059d1e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* fuse_lowlevel_ops::forget)(<a class="el" href="fuse__lowlevel_8h.html#a33e2aa4a8905a05397292ae047cd2257">fuse_req_t</a> req, <a class="el" href="fuse__lowlevel_8h.html#ab419149c707451eaf61b75afb852e016">fuse_ino_t</a> ino, unsigned long nlookup)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Forget about an inode</p>
<p>This function is called when the kernel removes an inode from its internal caches.</p>
<p>The inode's lookup count increases by one for every call to fuse_reply_entry and fuse_reply_create. The nlookup parameter indicates by how much the lookup count should be decreased.</p>
<p>Inodes with a non-zero lookup count may receive request from the kernel even after calls to unlink, rmdir or (when overwriting an existing file) rename. Filesystems must handle such requests properly and it is recommended to defer removal of the inode until the lookup count reaches zero. Calls to unlink, remdir or rename will be followed closely by forget unless the file or directory is open, in which case the kernel issues forget only after the release or releasedir calls.</p>
<p>Note that if a file system will be exported over NFS the inodes lifetime must extend even beyond forget. See the generation field in struct <a class="el" href="structfuse__entry__param.html">fuse_entry_param</a> above.</p>
<p>On unmount the lookup count for all inodes implicitly drops to zero. It is not guaranteed that the file system will receive corresponding forget messages for the affected inodes.</p>
<p>Valid replies: fuse_reply_none</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">req</td><td>request handle </td></tr>
    <tr><td class="paramname">ino</td><td>the inode number </td></tr>
    <tr><td class="paramname">nlookup</td><td>the number of lookups to forget </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a17808183820bb58dcc17db639511a2cb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* fuse_lowlevel_ops::forget_multi)(<a class="el" href="fuse__lowlevel_8h.html#a33e2aa4a8905a05397292ae047cd2257">fuse_req_t</a> req, size_t count, struct fuse_forget_data *forgets)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Forget about multiple inodes</p>
<p>See description of the forget function for more information.</p>
<p>Introduced in version 2.9</p>
<p>Valid replies: fuse_reply_none</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">req</td><td>request handle </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a81ff5a93a2edd71b063c2e827e0fd8d8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* fuse_lowlevel_ops::fsync)(<a class="el" href="fuse__lowlevel_8h.html#a33e2aa4a8905a05397292ae047cd2257">fuse_req_t</a> req, <a class="el" href="fuse__lowlevel_8h.html#ab419149c707451eaf61b75afb852e016">fuse_ino_t</a> ino, int datasync, struct <a class="el" href="structfuse__file__info.html">fuse_file_info</a> *fi)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Synchronize file contents</p>
<p>If the datasync parameter is non-zero, then only the user data should be flushed, not the meta data.</p>
<p>Valid replies: fuse_reply_err</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">req</td><td>request handle </td></tr>
    <tr><td class="paramname">ino</td><td>the inode number </td></tr>
    <tr><td class="paramname">datasync</td><td>flag indicating if only data should be flushed </td></tr>
    <tr><td class="paramname">fi</td><td>file information </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab2e3a9ad8b264daec4c254f5b064dfb3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* fuse_lowlevel_ops::fsyncdir)(<a class="el" href="fuse__lowlevel_8h.html#a33e2aa4a8905a05397292ae047cd2257">fuse_req_t</a> req, <a class="el" href="fuse__lowlevel_8h.html#ab419149c707451eaf61b75afb852e016">fuse_ino_t</a> ino, int datasync, struct <a class="el" href="structfuse__file__info.html">fuse_file_info</a> *fi)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Synchronize directory contents</p>
<p>If the datasync parameter is non-zero, then only the directory contents should be flushed, not the meta data.</p>
<p>fi-&gt;fh will contain the value set by the opendir method, or will be undefined if the opendir method didn't set any value.</p>
<p>Valid replies: fuse_reply_err</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">req</td><td>request handle </td></tr>
    <tr><td class="paramname">ino</td><td>the inode number </td></tr>
    <tr><td class="paramname">datasync</td><td>flag indicating if only data should be flushed </td></tr>
    <tr><td class="paramname">fi</td><td>file information </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a994c316fa7a1ca33525a4540675f6b47"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* fuse_lowlevel_ops::getattr)(<a class="el" href="fuse__lowlevel_8h.html#a33e2aa4a8905a05397292ae047cd2257">fuse_req_t</a> req, <a class="el" href="fuse__lowlevel_8h.html#ab419149c707451eaf61b75afb852e016">fuse_ino_t</a> ino, struct <a class="el" href="structfuse__file__info.html">fuse_file_info</a> *fi)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get file attributes</p>
<p>Valid replies: fuse_reply_attr fuse_reply_err</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">req</td><td>request handle </td></tr>
    <tr><td class="paramname">ino</td><td>the inode number </td></tr>
    <tr><td class="paramname">fi</td><td>for future use, currently always NULL </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a709d41ca0cde37dbd4d4d06c89f6906a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* fuse_lowlevel_ops::getlk)(<a class="el" href="fuse__lowlevel_8h.html#a33e2aa4a8905a05397292ae047cd2257">fuse_req_t</a> req, <a class="el" href="fuse__lowlevel_8h.html#ab419149c707451eaf61b75afb852e016">fuse_ino_t</a> ino, struct <a class="el" href="structfuse__file__info.html">fuse_file_info</a> *fi, struct <a class="el" href="structfuse__lowlevel__ops.html#a01b103e34d751d0456add93d9c34e711">flock</a> *lock)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Test for a POSIX file lock</p>
<p>Introduced in version 2.6</p>
<p>Valid replies: fuse_reply_lock fuse_reply_err</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">req</td><td>request handle </td></tr>
    <tr><td class="paramname">ino</td><td>the inode number </td></tr>
    <tr><td class="paramname">fi</td><td>file information </td></tr>
    <tr><td class="paramname">lock</td><td>the region/type to test </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aaed65c2801391c35ad0c60e73a0c43d9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* fuse_lowlevel_ops::getxattr)(<a class="el" href="fuse__lowlevel_8h.html#a33e2aa4a8905a05397292ae047cd2257">fuse_req_t</a> req, <a class="el" href="fuse__lowlevel_8h.html#ab419149c707451eaf61b75afb852e016">fuse_ino_t</a> ino, const char *name, size_t size)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get an extended attribute</p>
<p>If size is zero, the size of the value should be sent with fuse_reply_xattr.</p>
<p>If the size is non-zero, and the value fits in the buffer, the value should be sent with fuse_reply_buf.</p>
<p>If the size is too small for the value, the ERANGE error should be sent.</p>
<p>Valid replies: fuse_reply_buf fuse_reply_data fuse_reply_xattr fuse_reply_err</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">req</td><td>request handle </td></tr>
    <tr><td class="paramname">ino</td><td>the inode number </td></tr>
    <tr><td class="paramname">name</td><td>of the extended attribute </td></tr>
    <tr><td class="paramname">size</td><td>maximum size of the value to send </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab6fa0b9edb5b002cd1502c969c887329"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* fuse_lowlevel_ops::init)(void *userdata, struct <a class="el" href="structfuse__conn__info.html">fuse_conn_info</a> *conn)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initialize filesystem</p>
<p>Called before any other filesystem method</p>
<p>There's no reply to this function</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">userdata</td><td>the user data passed to <a class="el" href="fuse__lowlevel_8h.html#ab71e91777def283987cd8a504e926d01">fuse_lowlevel_new()</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a399da4f164985be5f5b93ef5b33551da"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* fuse_lowlevel_ops::ioctl)(<a class="el" href="fuse__lowlevel_8h.html#a33e2aa4a8905a05397292ae047cd2257">fuse_req_t</a> req, <a class="el" href="fuse__lowlevel_8h.html#ab419149c707451eaf61b75afb852e016">fuse_ino_t</a> ino, int cmd, void *arg, struct <a class="el" href="structfuse__file__info.html">fuse_file_info</a> *fi, unsigned flags, const void *in_buf, size_t in_bufsz, size_t out_bufsz)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Ioctl</p>
<p>Note: For unrestricted ioctls (not allowed for FUSE servers), data in and out areas can be discovered by giving iovs and setting FUSE_IOCTL_RETRY in . For restricted ioctls, kernel prepares in/out data area according to the information encoded in cmd.</p>
<p>Introduced in version 2.8</p>
<p>Valid replies: fuse_reply_ioctl_retry fuse_reply_ioctl fuse_reply_ioctl_iov fuse_reply_err</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">req</td><td>request handle </td></tr>
    <tr><td class="paramname">ino</td><td>the inode number </td></tr>
    <tr><td class="paramname">cmd</td><td>ioctl command </td></tr>
    <tr><td class="paramname">arg</td><td>ioctl argument </td></tr>
    <tr><td class="paramname">fi</td><td>file information </td></tr>
    <tr><td class="paramname">flags</td><td>for FUSE_IOCTL_* flags </td></tr>
    <tr><td class="paramname">in_buf</td><td>data fetched from the caller </td></tr>
    <tr><td class="paramname">in_bufsz</td><td>number of fetched bytes </td></tr>
    <tr><td class="paramname">out_bufsz</td><td>maximum size of output data </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a406798b81f44a8b54f188455c31b9be8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* fuse_lowlevel_ops::link)(<a class="el" href="fuse__lowlevel_8h.html#a33e2aa4a8905a05397292ae047cd2257">fuse_req_t</a> req, <a class="el" href="fuse__lowlevel_8h.html#ab419149c707451eaf61b75afb852e016">fuse_ino_t</a> ino, <a class="el" href="fuse__lowlevel_8h.html#ab419149c707451eaf61b75afb852e016">fuse_ino_t</a> newparent, const char *newname)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a hard link</p>
<p>Valid replies: fuse_reply_entry fuse_reply_err</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">req</td><td>request handle </td></tr>
    <tr><td class="paramname">ino</td><td>the old inode number </td></tr>
    <tr><td class="paramname">newparent</td><td>inode number of the new parent directory </td></tr>
    <tr><td class="paramname">newname</td><td>new name to create </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0f084e779f3fbd407bb5d0890bf0ef6b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* fuse_lowlevel_ops::listxattr)(<a class="el" href="fuse__lowlevel_8h.html#a33e2aa4a8905a05397292ae047cd2257">fuse_req_t</a> req, <a class="el" href="fuse__lowlevel_8h.html#ab419149c707451eaf61b75afb852e016">fuse_ino_t</a> ino, size_t size)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>List extended attribute names</p>
<p>If size is zero, the total size of the attribute list should be sent with fuse_reply_xattr.</p>
<p>If the size is non-zero, and the null character separated attribute list fits in the buffer, the list should be sent with fuse_reply_buf.</p>
<p>If the size is too small for the list, the ERANGE error should be sent.</p>
<p>Valid replies: fuse_reply_buf fuse_reply_data fuse_reply_xattr fuse_reply_err</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">req</td><td>request handle </td></tr>
    <tr><td class="paramname">ino</td><td>the inode number </td></tr>
    <tr><td class="paramname">size</td><td>maximum size of the list to send </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae8a2850c71bec355ad347413fa73f7c2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* fuse_lowlevel_ops::lookup)(<a class="el" href="fuse__lowlevel_8h.html#a33e2aa4a8905a05397292ae047cd2257">fuse_req_t</a> req, <a class="el" href="fuse__lowlevel_8h.html#ab419149c707451eaf61b75afb852e016">fuse_ino_t</a> parent, const char *name)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Look up a directory entry by name and get its attributes.</p>
<p>Valid replies: fuse_reply_entry fuse_reply_err</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">req</td><td>request handle </td></tr>
    <tr><td class="paramname">parent</td><td>inode number of the parent directory </td></tr>
    <tr><td class="paramname">name</td><td>the name to look up </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a23af0f6683447112848d9f1731e021d7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* fuse_lowlevel_ops::mkdir)(<a class="el" href="fuse__lowlevel_8h.html#a33e2aa4a8905a05397292ae047cd2257">fuse_req_t</a> req, <a class="el" href="fuse__lowlevel_8h.html#ab419149c707451eaf61b75afb852e016">fuse_ino_t</a> parent, const char *name, mode_t mode)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a directory</p>
<p>Valid replies: fuse_reply_entry fuse_reply_err</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">req</td><td>request handle </td></tr>
    <tr><td class="paramname">parent</td><td>inode number of the parent directory </td></tr>
    <tr><td class="paramname">name</td><td>to create </td></tr>
    <tr><td class="paramname">mode</td><td>with which to create the new file </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5cd44aa96291fa366d4ef40e2d1d1d76"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* fuse_lowlevel_ops::mknod)(<a class="el" href="fuse__lowlevel_8h.html#a33e2aa4a8905a05397292ae047cd2257">fuse_req_t</a> req, <a class="el" href="fuse__lowlevel_8h.html#ab419149c707451eaf61b75afb852e016">fuse_ino_t</a> parent, const char *name, mode_t mode, dev_t rdev)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create file node</p>
<p>Create a regular file, character device, block device, fifo or socket node.</p>
<p>Valid replies: fuse_reply_entry fuse_reply_err</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">req</td><td>request handle </td></tr>
    <tr><td class="paramname">parent</td><td>inode number of the parent directory </td></tr>
    <tr><td class="paramname">name</td><td>to create </td></tr>
    <tr><td class="paramname">mode</td><td>file type and mode with which to create the new file </td></tr>
    <tr><td class="paramname">rdev</td><td>the device number (only valid if created file is a device) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aab2f5186ecaa817e75ed443165288218"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* fuse_lowlevel_ops::open)(<a class="el" href="fuse__lowlevel_8h.html#a33e2aa4a8905a05397292ae047cd2257">fuse_req_t</a> req, <a class="el" href="fuse__lowlevel_8h.html#ab419149c707451eaf61b75afb852e016">fuse_ino_t</a> ino, struct <a class="el" href="structfuse__file__info.html">fuse_file_info</a> *fi)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Open a file</p>
<p>Open flags (with the exception of O_CREAT, O_EXCL, O_NOCTTY and O_TRUNC) are available in fi-&gt;flags.</p>
<p>Filesystem may store an arbitrary file handle (pointer, index, etc) in fi-&gt;fh, and use this in other all other file operations (read, write, flush, release, fsync).</p>
<p>Filesystem may also implement stateless file I/O and not store anything in fi-&gt;fh.</p>
<p>There are also some flags (direct_io, keep_cache) which the filesystem may set in fi, to change the way the file is opened. See <a class="el" href="structfuse__file__info.html">fuse_file_info</a> structure in &lt;<a class="el" href="fuse__common_8h.html">fuse_common.h</a>&gt; for more details.</p>
<p>Valid replies: fuse_reply_open fuse_reply_err</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">req</td><td>request handle </td></tr>
    <tr><td class="paramname">ino</td><td>the inode number </td></tr>
    <tr><td class="paramname">fi</td><td>file information </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a57a2c2d826fe11dd005d3275c3028d5e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* fuse_lowlevel_ops::opendir)(<a class="el" href="fuse__lowlevel_8h.html#a33e2aa4a8905a05397292ae047cd2257">fuse_req_t</a> req, <a class="el" href="fuse__lowlevel_8h.html#ab419149c707451eaf61b75afb852e016">fuse_ino_t</a> ino, struct <a class="el" href="structfuse__file__info.html">fuse_file_info</a> *fi)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Open a directory</p>
<p>Filesystem may store an arbitrary file handle (pointer, index, etc) in fi-&gt;fh, and use this in other all other directory stream operations (readdir, releasedir, fsyncdir).</p>
<p>Filesystem may also implement stateless directory I/O and not store anything in fi-&gt;fh, though that makes it impossible to implement standard conforming directory stream operations in case the contents of the directory can change between opendir and releasedir.</p>
<p>Valid replies: fuse_reply_open fuse_reply_err</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">req</td><td>request handle </td></tr>
    <tr><td class="paramname">ino</td><td>the inode number </td></tr>
    <tr><td class="paramname">fi</td><td>file information </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a50abf8a54b6c73a5a40123b6cf63c71e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* fuse_lowlevel_ops::poll)(<a class="el" href="fuse__lowlevel_8h.html#a33e2aa4a8905a05397292ae047cd2257">fuse_req_t</a> req, <a class="el" href="fuse__lowlevel_8h.html#ab419149c707451eaf61b75afb852e016">fuse_ino_t</a> ino, struct <a class="el" href="structfuse__file__info.html">fuse_file_info</a> *fi, struct fuse_pollhandle *ph)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Poll for IO readiness</p>
<p>Introduced in version 2.8</p>
<p>Note: If ph is non-NULL, the client should notify when IO readiness events occur by calling fuse_lowelevel_notify_poll() with the specified ph.</p>
<p>Regardless of the number of times poll with a non-NULL ph is received, single notification is enough to clear all. Notifying more times incurs overhead but doesn't harm correctness.</p>
<p>The callee is responsible for destroying ph with <a class="el" href="fuse__common_8h.html#adf5027f8a38b2efc03858efd7fdc756a">fuse_pollhandle_destroy()</a> when no longer in use.</p>
<p>Valid replies: fuse_reply_poll fuse_reply_err</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">req</td><td>request handle </td></tr>
    <tr><td class="paramname">ino</td><td>the inode number </td></tr>
    <tr><td class="paramname">fi</td><td>file information </td></tr>
    <tr><td class="paramname">ph</td><td>poll handle to be used for notification </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab7b740dccdc6ddc388cdcd7897e4c2e3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* fuse_lowlevel_ops::read)(<a class="el" href="fuse__lowlevel_8h.html#a33e2aa4a8905a05397292ae047cd2257">fuse_req_t</a> req, <a class="el" href="fuse__lowlevel_8h.html#ab419149c707451eaf61b75afb852e016">fuse_ino_t</a> ino, size_t size, off_t off, struct <a class="el" href="structfuse__file__info.html">fuse_file_info</a> *fi)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read data</p>
<p>Read should send exactly the number of bytes requested except on EOF or error, otherwise the rest of the data will be substituted with zeroes. An exception to this is when the file has been opened in 'direct_io' mode, in which case the return value of the read system call will reflect the return value of this operation.</p>
<p>fi-&gt;fh will contain the value set by the open method, or will be undefined if the open method didn't set any value.</p>
<p>Valid replies: fuse_reply_buf fuse_reply_iov fuse_reply_data fuse_reply_err</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">req</td><td>request handle </td></tr>
    <tr><td class="paramname">ino</td><td>the inode number </td></tr>
    <tr><td class="paramname">size</td><td>number of bytes to read </td></tr>
    <tr><td class="paramname">off</td><td>offset to read from </td></tr>
    <tr><td class="paramname">fi</td><td>file information </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af1ef8e59e0cb0b02dc0e406898aeaa51"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* fuse_lowlevel_ops::readdir)(<a class="el" href="fuse__lowlevel_8h.html#a33e2aa4a8905a05397292ae047cd2257">fuse_req_t</a> req, <a class="el" href="fuse__lowlevel_8h.html#ab419149c707451eaf61b75afb852e016">fuse_ino_t</a> ino, size_t size, off_t off, struct <a class="el" href="structfuse__file__info.html">fuse_file_info</a> *fi)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read directory</p>
<p>Send a buffer filled using <a class="el" href="fuse__lowlevel_8h.html#ad1957bcc8ece8c90f16c42c4daf3053f">fuse_add_direntry()</a>, with size not exceeding the requested size. Send an empty buffer on end of stream.</p>
<p>fi-&gt;fh will contain the value set by the opendir method, or will be undefined if the opendir method didn't set any value.</p>
<p>Valid replies: fuse_reply_buf fuse_reply_data fuse_reply_err</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">req</td><td>request handle </td></tr>
    <tr><td class="paramname">ino</td><td>the inode number </td></tr>
    <tr><td class="paramname">size</td><td>maximum number of bytes to send </td></tr>
    <tr><td class="paramname">off</td><td>offset to continue reading the directory stream </td></tr>
    <tr><td class="paramname">fi</td><td>file information </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae1032649069ae28d46bde76a40743fcf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* fuse_lowlevel_ops::readlink)(<a class="el" href="fuse__lowlevel_8h.html#a33e2aa4a8905a05397292ae047cd2257">fuse_req_t</a> req, <a class="el" href="fuse__lowlevel_8h.html#ab419149c707451eaf61b75afb852e016">fuse_ino_t</a> ino)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read symbolic link</p>
<p>Valid replies: fuse_reply_readlink fuse_reply_err</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">req</td><td>request handle </td></tr>
    <tr><td class="paramname">ino</td><td>the inode number </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="abc49c6310cd0eaddf116988426ca21d2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* fuse_lowlevel_ops::release)(<a class="el" href="fuse__lowlevel_8h.html#a33e2aa4a8905a05397292ae047cd2257">fuse_req_t</a> req, <a class="el" href="fuse__lowlevel_8h.html#ab419149c707451eaf61b75afb852e016">fuse_ino_t</a> ino, struct <a class="el" href="structfuse__file__info.html">fuse_file_info</a> *fi)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Release an open file</p>
<p>Release is called when there are no more references to an open file: all file descriptors are closed and all memory mappings are unmapped.</p>
<p>For every open call there will be exactly one release call.</p>
<p>The filesystem may reply with an error, but error values are not returned to close() or munmap() which triggered the release.</p>
<p>fi-&gt;fh will contain the value set by the open method, or will be undefined if the open method didn't set any value. fi-&gt;flags will contain the same flags as for open.</p>
<p>Valid replies: fuse_reply_err</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">req</td><td>request handle </td></tr>
    <tr><td class="paramname">ino</td><td>the inode number </td></tr>
    <tr><td class="paramname">fi</td><td>file information </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="abfc54ffe5fa5778fc273a6666494d802"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* fuse_lowlevel_ops::releasedir)(<a class="el" href="fuse__lowlevel_8h.html#a33e2aa4a8905a05397292ae047cd2257">fuse_req_t</a> req, <a class="el" href="fuse__lowlevel_8h.html#ab419149c707451eaf61b75afb852e016">fuse_ino_t</a> ino, struct <a class="el" href="structfuse__file__info.html">fuse_file_info</a> *fi)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Release an open directory</p>
<p>For every opendir call there will be exactly one releasedir call.</p>
<p>fi-&gt;fh will contain the value set by the opendir method, or will be undefined if the opendir method didn't set any value.</p>
<p>Valid replies: fuse_reply_err</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">req</td><td>request handle </td></tr>
    <tr><td class="paramname">ino</td><td>the inode number </td></tr>
    <tr><td class="paramname">fi</td><td>file information </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a15be6632986e6be8660071e1d71ffe51"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* fuse_lowlevel_ops::removexattr)(<a class="el" href="fuse__lowlevel_8h.html#a33e2aa4a8905a05397292ae047cd2257">fuse_req_t</a> req, <a class="el" href="fuse__lowlevel_8h.html#ab419149c707451eaf61b75afb852e016">fuse_ino_t</a> ino, const char *name)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Remove an extended attribute</p>
<p>Valid replies: fuse_reply_err</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">req</td><td>request handle </td></tr>
    <tr><td class="paramname">ino</td><td>the inode number </td></tr>
    <tr><td class="paramname">name</td><td>of the extended attribute </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aff3670fecb2b4bf45543c191c9d70c02"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* fuse_lowlevel_ops::rename)(<a class="el" href="fuse__lowlevel_8h.html#a33e2aa4a8905a05397292ae047cd2257">fuse_req_t</a> req, <a class="el" href="fuse__lowlevel_8h.html#ab419149c707451eaf61b75afb852e016">fuse_ino_t</a> parent, const char *name, <a class="el" href="fuse__lowlevel_8h.html#ab419149c707451eaf61b75afb852e016">fuse_ino_t</a> newparent, const char *newname)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Rename a file</p>
<p>If the target exists it should be atomically replaced. If the target's inode's lookup count is non-zero, the file system is expected to postpone any removal of the inode until the lookup count reaches zero (see description of the forget function).</p>
<p>Valid replies: fuse_reply_err</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">req</td><td>request handle </td></tr>
    <tr><td class="paramname">parent</td><td>inode number of the old parent directory </td></tr>
    <tr><td class="paramname">name</td><td>old name </td></tr>
    <tr><td class="paramname">newparent</td><td>inode number of the new parent directory </td></tr>
    <tr><td class="paramname">newname</td><td>new name </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1c1d7ad0c1fb40d7180660e7f3f7f089"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* fuse_lowlevel_ops::retrieve_reply)(<a class="el" href="fuse__lowlevel_8h.html#a33e2aa4a8905a05397292ae047cd2257">fuse_req_t</a> req, void *cookie, <a class="el" href="fuse__lowlevel_8h.html#ab419149c707451eaf61b75afb852e016">fuse_ino_t</a> ino, off_t offset, struct <a class="el" href="structfuse__bufvec.html">fuse_bufvec</a> *bufv)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Callback function for the retrieve request</p>
<p>Introduced in version 2.9</p>
<p>Valid replies: fuse_reply_none</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">req</td><td>request handle </td></tr>
    <tr><td class="paramname">cookie</td><td>user data supplied to <a class="el" href="fuse__lowlevel_8h.html#a8b2a260132708b581b00e1066b43faa8">fuse_lowlevel_notify_retrieve()</a> </td></tr>
    <tr><td class="paramname">ino</td><td>the inode number supplied to <a class="el" href="fuse__lowlevel_8h.html#a8b2a260132708b581b00e1066b43faa8">fuse_lowlevel_notify_retrieve()</a> </td></tr>
    <tr><td class="paramname">offset</td><td>the offset supplied to <a class="el" href="fuse__lowlevel_8h.html#a8b2a260132708b581b00e1066b43faa8">fuse_lowlevel_notify_retrieve()</a> </td></tr>
    <tr><td class="paramname">bufv</td><td>the buffer containing the returned data </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3cbf1eaf4366aed47fa5d991ea5ff0d5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* fuse_lowlevel_ops::rmdir)(<a class="el" href="fuse__lowlevel_8h.html#a33e2aa4a8905a05397292ae047cd2257">fuse_req_t</a> req, <a class="el" href="fuse__lowlevel_8h.html#ab419149c707451eaf61b75afb852e016">fuse_ino_t</a> parent, const char *name)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Remove a directory</p>
<p>If the directory's inode's lookup count is non-zero, the file system is expected to postpone any removal of the inode until the lookup count reaches zero (see description of the forget function).</p>
<p>Valid replies: fuse_reply_err</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">req</td><td>request handle </td></tr>
    <tr><td class="paramname">parent</td><td>inode number of the parent directory </td></tr>
    <tr><td class="paramname">name</td><td>to remove </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6a95408dd79575df7f6c64e55f1e973b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* fuse_lowlevel_ops::setattr)(<a class="el" href="fuse__lowlevel_8h.html#a33e2aa4a8905a05397292ae047cd2257">fuse_req_t</a> req, <a class="el" href="fuse__lowlevel_8h.html#ab419149c707451eaf61b75afb852e016">fuse_ino_t</a> ino, struct stat *attr, int to_set, struct <a class="el" href="structfuse__file__info.html">fuse_file_info</a> *fi)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set file attributes</p>
<p>In the 'attr' argument only members indicated by the 'to_set' bitmask contain valid values. Other members contain undefined values.</p>
<p>If the setattr was invoked from the ftruncate() system call under Linux kernel versions 2.6.15 or later, the fi-&gt;fh will contain the value set by the open method or will be undefined if the open method didn't set any value. Otherwise (not ftruncate call, or kernel version earlier than 2.6.15) the fi parameter will be NULL.</p>
<p>Valid replies: fuse_reply_attr fuse_reply_err</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">req</td><td>request handle </td></tr>
    <tr><td class="paramname">ino</td><td>the inode number </td></tr>
    <tr><td class="paramname">attr</td><td>the attributes </td></tr>
    <tr><td class="paramname">to_set</td><td>bit mask of attributes which should be set </td></tr>
    <tr><td class="paramname">fi</td><td>file information, or NULL</td></tr>
  </table>
  </dd>
</dl>
<p>Changed in version 2.5: file information filled in for ftruncate </p>

</div>
</div>
<a class="anchor" id="af290d78441583d1d6ba02da01904f328"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* fuse_lowlevel_ops::setlk)(<a class="el" href="fuse__lowlevel_8h.html#a33e2aa4a8905a05397292ae047cd2257">fuse_req_t</a> req, <a class="el" href="fuse__lowlevel_8h.html#ab419149c707451eaf61b75afb852e016">fuse_ino_t</a> ino, struct <a class="el" href="structfuse__file__info.html">fuse_file_info</a> *fi, struct <a class="el" href="structfuse__lowlevel__ops.html#a01b103e34d751d0456add93d9c34e711">flock</a> *lock, int sleep)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Acquire, modify or release a POSIX file lock</p>
<p>For POSIX threads (NPTL) there's a 1-1 relation between pid and owner, but otherwise this is not always the case. For checking lock ownership, 'fi-&gt;owner' must be used. The l_pid field in 'struct flock' should only be used to fill in this field in <a class="el" href="structfuse__lowlevel__ops.html#a709d41ca0cde37dbd4d4d06c89f6906a">getlk()</a>.</p>
<p>Note: if the locking methods are not implemented, the kernel will still allow file locking to work locally. Hence these are only interesting for network filesystems and similar.</p>
<p>Introduced in version 2.6</p>
<p>Valid replies: fuse_reply_err</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">req</td><td>request handle </td></tr>
    <tr><td class="paramname">ino</td><td>the inode number </td></tr>
    <tr><td class="paramname">fi</td><td>file information </td></tr>
    <tr><td class="paramname">lock</td><td>the region/type to set </td></tr>
    <tr><td class="paramname">sleep</td><td>locking operation may sleep </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab80c4081204c07a423c3c88b116f3086"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* fuse_lowlevel_ops::setxattr)(<a class="el" href="fuse__lowlevel_8h.html#a33e2aa4a8905a05397292ae047cd2257">fuse_req_t</a> req, <a class="el" href="fuse__lowlevel_8h.html#ab419149c707451eaf61b75afb852e016">fuse_ino_t</a> ino, const char *name, const char *value, size_t size, int flags)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set an extended attribute</p>
<p>Valid replies: fuse_reply_err </p>

</div>
</div>
<a class="anchor" id="aeea156121a28b519e284451721fb7d25"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* fuse_lowlevel_ops::statfs)(<a class="el" href="fuse__lowlevel_8h.html#a33e2aa4a8905a05397292ae047cd2257">fuse_req_t</a> req, <a class="el" href="fuse__lowlevel_8h.html#ab419149c707451eaf61b75afb852e016">fuse_ino_t</a> ino)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get file system statistics</p>
<p>Valid replies: fuse_reply_statfs fuse_reply_err</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">req</td><td>request handle </td></tr>
    <tr><td class="paramname">ino</td><td>the inode number, zero means "undefined" </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a30455cc58397c5a45434492d93a71af4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* fuse_lowlevel_ops::symlink)(<a class="el" href="fuse__lowlevel_8h.html#a33e2aa4a8905a05397292ae047cd2257">fuse_req_t</a> req, const char *<a class="el" href="structfuse__lowlevel__ops.html#a406798b81f44a8b54f188455c31b9be8">link</a>, <a class="el" href="fuse__lowlevel_8h.html#ab419149c707451eaf61b75afb852e016">fuse_ino_t</a> parent, const char *name)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a symbolic link</p>
<p>Valid replies: fuse_reply_entry fuse_reply_err</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">req</td><td>request handle </td></tr>
    <tr><td class="paramname">link</td><td>the contents of the symbolic link </td></tr>
    <tr><td class="paramname">parent</td><td>inode number of the parent directory </td></tr>
    <tr><td class="paramname">name</td><td>to create </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="afb6e186f5cbe806d3838a51c112a97ee"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* fuse_lowlevel_ops::unlink)(<a class="el" href="fuse__lowlevel_8h.html#a33e2aa4a8905a05397292ae047cd2257">fuse_req_t</a> req, <a class="el" href="fuse__lowlevel_8h.html#ab419149c707451eaf61b75afb852e016">fuse_ino_t</a> parent, const char *name)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Remove a file</p>
<p>If the file's inode's lookup count is non-zero, the file system is expected to postpone any removal of the inode until the lookup count reaches zero (see description of the forget function).</p>
<p>Valid replies: fuse_reply_err</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">req</td><td>request handle </td></tr>
    <tr><td class="paramname">parent</td><td>inode number of the parent directory </td></tr>
    <tr><td class="paramname">name</td><td>to remove </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a09cc5c1078cfb909513b5ca27464f53a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* fuse_lowlevel_ops::write)(<a class="el" href="fuse__lowlevel_8h.html#a33e2aa4a8905a05397292ae047cd2257">fuse_req_t</a> req, <a class="el" href="fuse__lowlevel_8h.html#ab419149c707451eaf61b75afb852e016">fuse_ino_t</a> ino, const char *buf, size_t size, off_t off, struct <a class="el" href="structfuse__file__info.html">fuse_file_info</a> *fi)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Write data</p>
<p>Write should return exactly the number of bytes requested except on error. An exception to this is when the file has been opened in 'direct_io' mode, in which case the return value of the write system call will reflect the return value of this operation.</p>
<p>fi-&gt;fh will contain the value set by the open method, or will be undefined if the open method didn't set any value.</p>
<p>Valid replies: fuse_reply_write fuse_reply_err</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">req</td><td>request handle </td></tr>
    <tr><td class="paramname">ino</td><td>the inode number </td></tr>
    <tr><td class="paramname">buf</td><td>data to write </td></tr>
    <tr><td class="paramname">size</td><td>number of bytes to write </td></tr>
    <tr><td class="paramname">off</td><td>offset to write to </td></tr>
    <tr><td class="paramname">fi</td><td>file information </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3b40ed06d1297f244363a8dcd40d44aa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* fuse_lowlevel_ops::write_buf)(<a class="el" href="fuse__lowlevel_8h.html#a33e2aa4a8905a05397292ae047cd2257">fuse_req_t</a> req, <a class="el" href="fuse__lowlevel_8h.html#ab419149c707451eaf61b75afb852e016">fuse_ino_t</a> ino, struct <a class="el" href="structfuse__bufvec.html">fuse_bufvec</a> *bufv, off_t off, struct <a class="el" href="structfuse__file__info.html">fuse_file_info</a> *fi)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Write data made available in a buffer</p>
<p>This is a more generic version of the -&gt;<a class="el" href="structfuse__lowlevel__ops.html#a09cc5c1078cfb909513b5ca27464f53a">write()</a> method. If FUSE_CAP_SPLICE_READ is set in <a class="el" href="structfuse__conn__info.html#af45de81548b591f3004353a324e4e04d">fuse_conn_info.want</a> and the kernel supports splicing from the fuse device, then the data will be made available in pipe for supporting zero copy data transfer.</p>
<p>buf-&gt;count is guaranteed to be one (and thus buf-&gt;idx is always zero). The write_buf handler must ensure that bufv-&gt;off is correctly updated (reflecting the number of bytes read from bufv-&gt;buf[0]).</p>
<p>Introduced in version 2.9</p>
<p>Valid replies: fuse_reply_write fuse_reply_err</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">req</td><td>request handle </td></tr>
    <tr><td class="paramname">ino</td><td>the inode number </td></tr>
    <tr><td class="paramname">bufv</td><td>buffer containing the data </td></tr>
    <tr><td class="paramname">off</td><td>offset to write to </td></tr>
    <tr><td class="paramname">fi</td><td>file information </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li>include/<a class="el" href="fuse__lowlevel_8h.html">fuse_lowlevel.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sat Apr 23 2016 09:43:20 for fuse by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.8
</small></address>
</body>
</html>
