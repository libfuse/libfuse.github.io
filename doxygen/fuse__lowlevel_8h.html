<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.8"/>
<title>libfuse: include/fuse_lowlevel.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">libfuse
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.8 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_d44c64559bbebec7f509842c48db8b23.html">include</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">fuse_lowlevel.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;<a class="el" href="fuse__common_8h.html">fuse_common.h</a>&quot;</code><br />
<code>#include &lt;utime.h&gt;</code><br />
<code>#include &lt;fcntl.h&gt;</code><br />
<code>#include &lt;sys/types.h&gt;</code><br />
<code>#include &lt;sys/stat.h&gt;</code><br />
<code>#include &lt;sys/statvfs.h&gt;</code><br />
<code>#include &lt;sys/uio.h&gt;</code><br />
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfuse__entry__param.html">fuse_entry_param</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfuse__ctx.html">fuse_ctx</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfuse__lowlevel__ops.html">fuse_lowlevel_ops</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a14d7299559cf05272b838cfc6388ef91"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fuse__lowlevel_8h.html#a14d7299559cf05272b838cfc6388ef91">FUSE_ROOT_ID</a>&#160;&#160;&#160;1</td></tr>
<tr class="separator:a14d7299559cf05272b838cfc6388ef91"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ad119a72f00b4cd2e4a500fd3364ae1e2"><td class="memItemLeft" align="right" valign="top">typedef uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fuse__lowlevel_8h.html#ad119a72f00b4cd2e4a500fd3364ae1e2">fuse_ino_t</a></td></tr>
<tr class="separator:ad119a72f00b4cd2e4a500fd3364ae1e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33e2aa4a8905a05397292ae047cd2257"><td class="memItemLeft" align="right" valign="top">typedef struct fuse_req *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fuse__lowlevel_8h.html#a33e2aa4a8905a05397292ae047cd2257">fuse_req_t</a></td></tr>
<tr class="separator:a33e2aa4a8905a05397292ae047cd2257"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bb8b555b1d9d8a38b8c6cac28d51f1e"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fuse__lowlevel_8h.html#a5bb8b555b1d9d8a38b8c6cac28d51f1e">fuse_interrupt_func_t</a> )(<a class="el" href="fuse__lowlevel_8h.html#a33e2aa4a8905a05397292ae047cd2257">fuse_req_t</a> req, void *data)</td></tr>
<tr class="separator:a5bb8b555b1d9d8a38b8c6cac28d51f1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a2553c03f9a63c75e609e67f90a3a5d88"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fuse__lowlevel_8h.html#a2553c03f9a63c75e609e67f90a3a5d88">fuse_reply_err</a> (<a class="el" href="fuse__lowlevel_8h.html#a33e2aa4a8905a05397292ae047cd2257">fuse_req_t</a> req, int err)</td></tr>
<tr class="separator:a2553c03f9a63c75e609e67f90a3a5d88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85ae91390a6704dc26f8d80fed7d5678"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fuse__lowlevel_8h.html#a85ae91390a6704dc26f8d80fed7d5678">fuse_reply_none</a> (<a class="el" href="fuse__lowlevel_8h.html#a33e2aa4a8905a05397292ae047cd2257">fuse_req_t</a> req)</td></tr>
<tr class="separator:a85ae91390a6704dc26f8d80fed7d5678"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a672c45e126cd240f4bcd59bf9b7e3708"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fuse__lowlevel_8h.html#a672c45e126cd240f4bcd59bf9b7e3708">fuse_reply_entry</a> (<a class="el" href="fuse__lowlevel_8h.html#a33e2aa4a8905a05397292ae047cd2257">fuse_req_t</a> req, const struct <a class="el" href="structfuse__entry__param.html">fuse_entry_param</a> *e)</td></tr>
<tr class="separator:a672c45e126cd240f4bcd59bf9b7e3708"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abea78d22349198f8370d7cb91fbf05ed"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fuse__lowlevel_8h.html#abea78d22349198f8370d7cb91fbf05ed">fuse_reply_create</a> (<a class="el" href="fuse__lowlevel_8h.html#a33e2aa4a8905a05397292ae047cd2257">fuse_req_t</a> req, const struct <a class="el" href="structfuse__entry__param.html">fuse_entry_param</a> *e, const struct <a class="el" href="structfuse__file__info.html">fuse_file_info</a> *fi)</td></tr>
<tr class="separator:abea78d22349198f8370d7cb91fbf05ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad28378dc569019c32acdb4995d70be18"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fuse__lowlevel_8h.html#ad28378dc569019c32acdb4995d70be18">fuse_reply_attr</a> (<a class="el" href="fuse__lowlevel_8h.html#a33e2aa4a8905a05397292ae047cd2257">fuse_req_t</a> req, const struct stat *attr, double attr_timeout)</td></tr>
<tr class="separator:ad28378dc569019c32acdb4995d70be18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a5872d7f73f0bd593e00788a4c7bbb7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fuse__lowlevel_8h.html#a5a5872d7f73f0bd593e00788a4c7bbb7">fuse_reply_readlink</a> (<a class="el" href="fuse__lowlevel_8h.html#a33e2aa4a8905a05397292ae047cd2257">fuse_req_t</a> req, const char *link)</td></tr>
<tr class="separator:a5a5872d7f73f0bd593e00788a4c7bbb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a170f8c6b953d70928e83bcecee43bfdc"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fuse__lowlevel_8h.html#a170f8c6b953d70928e83bcecee43bfdc">fuse_reply_open</a> (<a class="el" href="fuse__lowlevel_8h.html#a33e2aa4a8905a05397292ae047cd2257">fuse_req_t</a> req, const struct <a class="el" href="structfuse__file__info.html">fuse_file_info</a> *fi)</td></tr>
<tr class="separator:a170f8c6b953d70928e83bcecee43bfdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3cfa73f61d6ef461ab5a3fbf859eb97"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fuse__lowlevel_8h.html#aa3cfa73f61d6ef461ab5a3fbf859eb97">fuse_reply_write</a> (<a class="el" href="fuse__lowlevel_8h.html#a33e2aa4a8905a05397292ae047cd2257">fuse_req_t</a> req, size_t count)</td></tr>
<tr class="separator:aa3cfa73f61d6ef461ab5a3fbf859eb97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a300a88b63ab7c8ca92853a97486448c0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fuse__lowlevel_8h.html#a300a88b63ab7c8ca92853a97486448c0">fuse_reply_buf</a> (<a class="el" href="fuse__lowlevel_8h.html#a33e2aa4a8905a05397292ae047cd2257">fuse_req_t</a> req, const char *buf, size_t size)</td></tr>
<tr class="separator:a300a88b63ab7c8ca92853a97486448c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1242694fe0fb6e253a88b57795987302"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fuse__lowlevel_8h.html#a1242694fe0fb6e253a88b57795987302">fuse_reply_data</a> (<a class="el" href="fuse__lowlevel_8h.html#a33e2aa4a8905a05397292ae047cd2257">fuse_req_t</a> req, struct <a class="el" href="structfuse__bufvec.html">fuse_bufvec</a> *bufv, enum <a class="el" href="fuse__common_8h.html#aec0ad71a3e8c357ebe7e87cdecbdbe18">fuse_buf_copy_flags</a> flags)</td></tr>
<tr class="separator:a1242694fe0fb6e253a88b57795987302"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fbbf591a55f09c02cd54d34bdbfe0e9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fuse__lowlevel_8h.html#a5fbbf591a55f09c02cd54d34bdbfe0e9">fuse_reply_iov</a> (<a class="el" href="fuse__lowlevel_8h.html#a33e2aa4a8905a05397292ae047cd2257">fuse_req_t</a> req, const struct iovec *iov, int count)</td></tr>
<tr class="separator:a5fbbf591a55f09c02cd54d34bdbfe0e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1d95ec3ca674253baac3639ea10f0ff"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fuse__lowlevel_8h.html#aa1d95ec3ca674253baac3639ea10f0ff">fuse_reply_statfs</a> (<a class="el" href="fuse__lowlevel_8h.html#a33e2aa4a8905a05397292ae047cd2257">fuse_req_t</a> req, const struct statvfs *stbuf)</td></tr>
<tr class="separator:aa1d95ec3ca674253baac3639ea10f0ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afed32e5d3e1f54d390103f79ebb8bd42"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fuse__lowlevel_8h.html#afed32e5d3e1f54d390103f79ebb8bd42">fuse_reply_xattr</a> (<a class="el" href="fuse__lowlevel_8h.html#a33e2aa4a8905a05397292ae047cd2257">fuse_req_t</a> req, size_t count)</td></tr>
<tr class="separator:afed32e5d3e1f54d390103f79ebb8bd42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a135eda9b7d36fb4eaae2de58526d4f85"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fuse__lowlevel_8h.html#a135eda9b7d36fb4eaae2de58526d4f85">fuse_reply_lock</a> (<a class="el" href="fuse__lowlevel_8h.html#a33e2aa4a8905a05397292ae047cd2257">fuse_req_t</a> req, const struct flock *lock)</td></tr>
<tr class="separator:a135eda9b7d36fb4eaae2de58526d4f85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65431e8196e0533257acad767f7b074f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fuse__lowlevel_8h.html#a65431e8196e0533257acad767f7b074f">fuse_reply_bmap</a> (<a class="el" href="fuse__lowlevel_8h.html#a33e2aa4a8905a05397292ae047cd2257">fuse_req_t</a> req, uint64_t idx)</td></tr>
<tr class="separator:a65431e8196e0533257acad767f7b074f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1957bcc8ece8c90f16c42c4daf3053f"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fuse__lowlevel_8h.html#ad1957bcc8ece8c90f16c42c4daf3053f">fuse_add_direntry</a> (<a class="el" href="fuse__lowlevel_8h.html#a33e2aa4a8905a05397292ae047cd2257">fuse_req_t</a> req, char *buf, size_t bufsize, const char *name, const struct stat *stbuf, off_t off)</td></tr>
<tr class="separator:ad1957bcc8ece8c90f16c42c4daf3053f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34f3f1beebacab5f717d95baf832a8a5"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fuse__lowlevel_8h.html#a34f3f1beebacab5f717d95baf832a8a5">fuse_add_direntry_plus</a> (<a class="el" href="fuse__lowlevel_8h.html#a33e2aa4a8905a05397292ae047cd2257">fuse_req_t</a> req, char *buf, size_t bufsize, const char *name, const struct <a class="el" href="structfuse__entry__param.html">fuse_entry_param</a> *e, off_t off)</td></tr>
<tr class="separator:a34f3f1beebacab5f717d95baf832a8a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a940683d07df12c24f56b4363aed90e4d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fuse__lowlevel_8h.html#a940683d07df12c24f56b4363aed90e4d">fuse_reply_ioctl_retry</a> (<a class="el" href="fuse__lowlevel_8h.html#a33e2aa4a8905a05397292ae047cd2257">fuse_req_t</a> req, const struct iovec *in_iov, size_t in_count, const struct iovec *out_iov, size_t out_count)</td></tr>
<tr class="separator:a940683d07df12c24f56b4363aed90e4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf7f34f470c04f276b7091ad3b3dcb31"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fuse__lowlevel_8h.html#adf7f34f470c04f276b7091ad3b3dcb31">fuse_reply_ioctl</a> (<a class="el" href="fuse__lowlevel_8h.html#a33e2aa4a8905a05397292ae047cd2257">fuse_req_t</a> req, int result, const void *buf, size_t size)</td></tr>
<tr class="separator:adf7f34f470c04f276b7091ad3b3dcb31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37381eb84c39e5fe3af9f3ef507aeeb7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fuse__lowlevel_8h.html#a37381eb84c39e5fe3af9f3ef507aeeb7">fuse_reply_ioctl_iov</a> (<a class="el" href="fuse__lowlevel_8h.html#a33e2aa4a8905a05397292ae047cd2257">fuse_req_t</a> req, int result, const struct iovec *iov, int count)</td></tr>
<tr class="separator:a37381eb84c39e5fe3af9f3ef507aeeb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2172d260d34c76c25cd601870aee4220"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fuse__lowlevel_8h.html#a2172d260d34c76c25cd601870aee4220">fuse_reply_poll</a> (<a class="el" href="fuse__lowlevel_8h.html#a33e2aa4a8905a05397292ae047cd2257">fuse_req_t</a> req, unsigned revents)</td></tr>
<tr class="separator:a2172d260d34c76c25cd601870aee4220"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab078685b1f480188031fc40aa2e2fbca"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fuse__lowlevel_8h.html#ab078685b1f480188031fc40aa2e2fbca">fuse_lowlevel_notify_poll</a> (struct fuse_pollhandle *ph)</td></tr>
<tr class="separator:ab078685b1f480188031fc40aa2e2fbca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cb974af9745294ff446d11cba2422f1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fuse__lowlevel_8h.html#a9cb974af9745294ff446d11cba2422f1">fuse_lowlevel_notify_inval_inode</a> (struct fuse_session *se, <a class="el" href="fuse__lowlevel_8h.html#ad119a72f00b4cd2e4a500fd3364ae1e2">fuse_ino_t</a> ino, off_t off, off_t len)</td></tr>
<tr class="separator:a9cb974af9745294ff446d11cba2422f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab14032b74b0a57a2b3155dd6ba8d6095"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fuse__lowlevel_8h.html#ab14032b74b0a57a2b3155dd6ba8d6095">fuse_lowlevel_notify_inval_entry</a> (struct fuse_session *se, <a class="el" href="fuse__lowlevel_8h.html#ad119a72f00b4cd2e4a500fd3364ae1e2">fuse_ino_t</a> parent, const char *name, size_t namelen)</td></tr>
<tr class="separator:ab14032b74b0a57a2b3155dd6ba8d6095"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a399a43ff69a20ce42082a81eb1517992"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fuse__lowlevel_8h.html#a399a43ff69a20ce42082a81eb1517992">fuse_lowlevel_notify_delete</a> (struct fuse_session *se, <a class="el" href="fuse__lowlevel_8h.html#ad119a72f00b4cd2e4a500fd3364ae1e2">fuse_ino_t</a> parent, <a class="el" href="fuse__lowlevel_8h.html#ad119a72f00b4cd2e4a500fd3364ae1e2">fuse_ino_t</a> child, const char *name, size_t namelen)</td></tr>
<tr class="separator:a399a43ff69a20ce42082a81eb1517992"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af856725ed4a13ed7c17512554043edbc"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fuse__lowlevel_8h.html#af856725ed4a13ed7c17512554043edbc">fuse_lowlevel_notify_store</a> (struct fuse_session *se, <a class="el" href="fuse__lowlevel_8h.html#ad119a72f00b4cd2e4a500fd3364ae1e2">fuse_ino_t</a> ino, off_t offset, struct <a class="el" href="structfuse__bufvec.html">fuse_bufvec</a> *bufv, enum <a class="el" href="fuse__common_8h.html#aec0ad71a3e8c357ebe7e87cdecbdbe18">fuse_buf_copy_flags</a> flags)</td></tr>
<tr class="separator:af856725ed4a13ed7c17512554043edbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58cb3543209d2c29dc2830f2503b5058"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fuse__lowlevel_8h.html#a58cb3543209d2c29dc2830f2503b5058">fuse_lowlevel_notify_retrieve</a> (struct fuse_session *se, <a class="el" href="fuse__lowlevel_8h.html#ad119a72f00b4cd2e4a500fd3364ae1e2">fuse_ino_t</a> ino, size_t size, off_t offset, void *cookie)</td></tr>
<tr class="separator:a58cb3543209d2c29dc2830f2503b5058"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab00273c65d124e44abcf2374f9c504b"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fuse__lowlevel_8h.html#aab00273c65d124e44abcf2374f9c504b">fuse_req_userdata</a> (<a class="el" href="fuse__lowlevel_8h.html#a33e2aa4a8905a05397292ae047cd2257">fuse_req_t</a> req)</td></tr>
<tr class="separator:aab00273c65d124e44abcf2374f9c504b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1d1963190eb93ae5667d32d2b387ca1"><td class="memItemLeft" align="right" valign="top">const struct <a class="el" href="structfuse__ctx.html">fuse_ctx</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fuse__lowlevel_8h.html#ad1d1963190eb93ae5667d32d2b387ca1">fuse_req_ctx</a> (<a class="el" href="fuse__lowlevel_8h.html#a33e2aa4a8905a05397292ae047cd2257">fuse_req_t</a> req)</td></tr>
<tr class="separator:ad1d1963190eb93ae5667d32d2b387ca1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57f4dabcf044aafcdba6c4682b3a1869"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fuse__lowlevel_8h.html#a57f4dabcf044aafcdba6c4682b3a1869">fuse_req_getgroups</a> (<a class="el" href="fuse__lowlevel_8h.html#a33e2aa4a8905a05397292ae047cd2257">fuse_req_t</a> req, int size, gid_t list[])</td></tr>
<tr class="separator:a57f4dabcf044aafcdba6c4682b3a1869"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3cdb9744f033e37a72984489343940f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fuse__lowlevel_8h.html#ab3cdb9744f033e37a72984489343940f">fuse_req_interrupt_func</a> (<a class="el" href="fuse__lowlevel_8h.html#a33e2aa4a8905a05397292ae047cd2257">fuse_req_t</a> req, <a class="el" href="fuse__lowlevel_8h.html#a5bb8b555b1d9d8a38b8c6cac28d51f1e">fuse_interrupt_func_t</a> func, void *data)</td></tr>
<tr class="separator:ab3cdb9744f033e37a72984489343940f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52674fc627647f33e63c74267f0f1f9d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fuse__lowlevel_8h.html#a52674fc627647f33e63c74267f0f1f9d">fuse_req_interrupted</a> (<a class="el" href="fuse__lowlevel_8h.html#a33e2aa4a8905a05397292ae047cd2257">fuse_req_t</a> req)</td></tr>
<tr class="separator:a52674fc627647f33e63c74267f0f1f9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6e2d0fde62dcf4f0e57afeabeefd7b1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fuse__lowlevel_8h.html#ac6e2d0fde62dcf4f0e57afeabeefd7b1">fuse_lowlevel_version</a> (void)</td></tr>
<tr class="separator:ac6e2d0fde62dcf4f0e57afeabeefd7b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a990af0becaba1b5e45781d399720f85e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fuse__lowlevel_8h.html#a990af0becaba1b5e45781d399720f85e">fuse_lowlevel_help</a> (void)</td></tr>
<tr class="separator:a990af0becaba1b5e45781d399720f85e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7235e3a2d1c780d5e0beaee13c81529f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fuse__lowlevel_8h.html#a7235e3a2d1c780d5e0beaee13c81529f">fuse_cmdline_help</a> (void)</td></tr>
<tr class="separator:a7235e3a2d1c780d5e0beaee13c81529f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8421a0cb3b6fb7013c7272c6997d1e08"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fuse__lowlevel_8h.html#a8421a0cb3b6fb7013c7272c6997d1e08">fuse_parse_cmdline</a> (struct <a class="el" href="structfuse__args.html">fuse_args</a> *args, struct fuse_cmdline_opts *opts)</td></tr>
<tr class="separator:a8421a0cb3b6fb7013c7272c6997d1e08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ee52f81d0c63d9bd46b11314ba596cf"><td class="memItemLeft" align="right" valign="top">struct fuse_session *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fuse__lowlevel_8h.html#a9ee52f81d0c63d9bd46b11314ba596cf">fuse_session_new</a> (struct <a class="el" href="structfuse__args.html">fuse_args</a> *args, const struct <a class="el" href="structfuse__lowlevel__ops.html">fuse_lowlevel_ops</a> *op, size_t op_size, void *userdata)</td></tr>
<tr class="separator:a9ee52f81d0c63d9bd46b11314ba596cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6d77679a110582684e9ca2da623bbc2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fuse__lowlevel_8h.html#aa6d77679a110582684e9ca2da623bbc2">fuse_session_mount</a> (struct fuse_session *se, const char *mountpoint)</td></tr>
<tr class="separator:aa6d77679a110582684e9ca2da623bbc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f1e538aa3287e251afbe985438c4249"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fuse__lowlevel_8h.html#a5f1e538aa3287e251afbe985438c4249">fuse_session_loop</a> (struct fuse_session *se)</td></tr>
<tr class="separator:a5f1e538aa3287e251afbe985438c4249"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ae949b229431e278bce6d8af271c23c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fuse__lowlevel_8h.html#a0ae949b229431e278bce6d8af271c23c">fuse_session_loop_mt</a> (struct fuse_session *se, int clone_fd)</td></tr>
<tr class="separator:a0ae949b229431e278bce6d8af271c23c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a198429f3fbc23ef29ef9971271827690"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fuse__lowlevel_8h.html#a198429f3fbc23ef29ef9971271827690">fuse_session_exit</a> (struct fuse_session *se)</td></tr>
<tr class="separator:a198429f3fbc23ef29ef9971271827690"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3d015de77ae0edeb3157321e7a5c434"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fuse__lowlevel_8h.html#ab3d015de77ae0edeb3157321e7a5c434">fuse_session_reset</a> (struct fuse_session *se)</td></tr>
<tr class="separator:ab3d015de77ae0edeb3157321e7a5c434"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41b12193fa1520ff658d65679f4e513c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fuse__lowlevel_8h.html#a41b12193fa1520ff658d65679f4e513c">fuse_session_exited</a> (struct fuse_session *se)</td></tr>
<tr class="separator:a41b12193fa1520ff658d65679f4e513c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c10d942751ddb214863a8b5e53de5e8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fuse__lowlevel_8h.html#a6c10d942751ddb214863a8b5e53de5e8">fuse_session_unmount</a> (struct fuse_session *se)</td></tr>
<tr class="separator:a6c10d942751ddb214863a8b5e53de5e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08b5503c4e9656f9c4bc88331233cc65"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fuse__lowlevel_8h.html#a08b5503c4e9656f9c4bc88331233cc65">fuse_session_destroy</a> (struct fuse_session *se)</td></tr>
<tr class="separator:a08b5503c4e9656f9c4bc88331233cc65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bf19badb53d92d31d6b2fb131546a2d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fuse__lowlevel_8h.html#a4bf19badb53d92d31d6b2fb131546a2d">fuse_session_fd</a> (struct fuse_session *se)</td></tr>
<tr class="separator:a4bf19badb53d92d31d6b2fb131546a2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a411ee86ec4657ea954402a9ca263e6d0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fuse__lowlevel_8h.html#a411ee86ec4657ea954402a9ca263e6d0">fuse_session_process_buf</a> (struct fuse_session *se, const struct <a class="el" href="structfuse__buf.html">fuse_buf</a> *buf)</td></tr>
<tr class="separator:a411ee86ec4657ea954402a9ca263e6d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa434f1c9e7d71c4ed219c4dc3b1deae7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fuse__lowlevel_8h.html#aa434f1c9e7d71c4ed219c4dc3b1deae7">fuse_session_receive_buf</a> (struct fuse_session *se, struct <a class="el" href="structfuse__buf.html">fuse_buf</a> *buf)</td></tr>
<tr class="separator:aa434f1c9e7d71c4ed219c4dc3b1deae7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Low level API</p>
<p>IMPORTANT: you should define FUSE_USE_VERSION before including this header. To use the newest API define it to 30 (recommended for any new application). </p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="a14d7299559cf05272b838cfc6388ef91"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FUSE_ROOT_ID&#160;&#160;&#160;1</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The node ID of the root inode </p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="ad119a72f00b4cd2e4a500fd3364ae1e2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef uint64_t <a class="el" href="fuse__lowlevel_8h.html#ad119a72f00b4cd2e4a500fd3364ae1e2">fuse_ino_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Inode number type </p>

</div>
</div>
<a class="anchor" id="a5bb8b555b1d9d8a38b8c6cac28d51f1e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* fuse_interrupt_func_t)(<a class="el" href="fuse__lowlevel_8h.html#a33e2aa4a8905a05397292ae047cd2257">fuse_req_t</a> req, void *data)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Callback function for an interrupt</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">req</td><td>interrupted request </td></tr>
    <tr><td class="paramname">data</td><td>user data </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a33e2aa4a8905a05397292ae047cd2257"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct fuse_req* <a class="el" href="fuse__lowlevel_8h.html#a33e2aa4a8905a05397292ae047cd2257">fuse_req_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Request pointer type </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ad1957bcc8ece8c90f16c42c4daf3053f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t fuse_add_direntry </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="fuse__lowlevel_8h.html#a33e2aa4a8905a05397292ae047cd2257">fuse_req_t</a>&#160;</td>
          <td class="paramname"><em>req</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bufsize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct stat *&#160;</td>
          <td class="paramname"><em>stbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">off_t&#160;</td>
          <td class="paramname"><em>off</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add a directory entry to the buffer</p>
<p>Buffer needs to be large enough to hold the entry. If it's not, then the entry is not filled in but the size of the entry is still returned. The caller can check this by comparing the bufsize parameter with the returned entry size. If the entry size is larger than the buffer size, the operation failed.</p>
<p>From the 'stbuf' argument the st_ino field and bits 12-15 of the st_mode field are used. The other fields are ignored.</p>
<p>Note: offsets do not necessarily represent physical offsets, and could be any marker, that enables the implementation to find a specific point in the directory stream.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">req</td><td>request handle </td></tr>
    <tr><td class="paramname">buf</td><td>the point where the new entry will be added to the buffer </td></tr>
    <tr><td class="paramname">bufsize</td><td>remaining size of the buffer </td></tr>
    <tr><td class="paramname">name</td><td>the name of the entry </td></tr>
    <tr><td class="paramname">stbuf</td><td>the file attributes </td></tr>
    <tr><td class="paramname">off</td><td>the offset of the next entry </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the space needed for the entry </dd></dl>

</div>
</div>
<a class="anchor" id="a34f3f1beebacab5f717d95baf832a8a5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t fuse_add_direntry_plus </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="fuse__lowlevel_8h.html#a33e2aa4a8905a05397292ae047cd2257">fuse_req_t</a>&#160;</td>
          <td class="paramname"><em>req</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bufsize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structfuse__entry__param.html">fuse_entry_param</a> *&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">off_t&#160;</td>
          <td class="paramname"><em>off</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add a directory entry to the buffer with the attributes</p>
<p>Buffer needs to be large enough to hold the entry. If it's not, then the entry is not filled in but the size of the entry is still returned. The caller can check this by comparing the bufsize parameter with the returned entry size. If the entry size is larger than the buffer size, the operation failed.</p>
<p>From the 'stbuf' argument the st_ino field and bits 12-15 of the st_mode field are used. The other fields are ignored.</p>
<p>Note: offsets do not necessarily represent physical offsets, and could be any marker, that enables the implementation to find a specific point in the directory stream.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">req</td><td>request handle </td></tr>
    <tr><td class="paramname">buf</td><td>the point where the new entry will be added to the buffer </td></tr>
    <tr><td class="paramname">bufsize</td><td>remaining size of the buffer </td></tr>
    <tr><td class="paramname">name</td><td>the name of the entry </td></tr>
    <tr><td class="paramname">e</td><td>the directory entry </td></tr>
    <tr><td class="paramname">off</td><td>the offset of the next entry </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the space needed for the entry </dd></dl>

</div>
</div>
<a class="anchor" id="a7235e3a2d1c780d5e0beaee13c81529f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fuse_cmdline_help </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Print available options for <code><a class="el" href="fuse__lowlevel_8h.html#a8421a0cb3b6fb7013c7272c6997d1e08">fuse_parse_cmdline()</a></code>. </p>

</div>
</div>
<a class="anchor" id="a990af0becaba1b5e45781d399720f85e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fuse_lowlevel_help </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Print available low-level options to stdout. This is not an exhaustive list, but includes only those options that may be of interest to an end-user of a file system. </p>

</div>
</div>
<a class="anchor" id="a399a43ff69a20ce42082a81eb1517992"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int fuse_lowlevel_notify_delete </td>
          <td>(</td>
          <td class="paramtype">struct fuse_session *&#160;</td>
          <td class="paramname"><em>se</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="fuse__lowlevel_8h.html#ad119a72f00b4cd2e4a500fd3364ae1e2">fuse_ino_t</a>&#160;</td>
          <td class="paramname"><em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="fuse__lowlevel_8h.html#ad119a72f00b4cd2e4a500fd3364ae1e2">fuse_ino_t</a>&#160;</td>
          <td class="paramname"><em>child</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>namelen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>As of kernel 4.8, this function behaves like <a class="el" href="fuse__lowlevel_8h.html#ab14032b74b0a57a2b3155dd6ba8d6095">fuse_lowlevel_notify_inval_entry()</a> with the following additional effect:</p>
<p>If the provided <em>child</em> inode matches the inode that is currently associated with the cached dentry, and if there are any inotify watches registered for the dentry, then the watchers are informed that the dentry has been deleted.</p>
<p>To avoid a deadlock don't call this function from a filesystem operation and don't call it with a lock held that can also be held by a filesystem operation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">se</td><td>the session object </td></tr>
    <tr><td class="paramname">parent</td><td>inode number </td></tr>
    <tr><td class="paramname">child</td><td>inode number </td></tr>
    <tr><td class="paramname">name</td><td>file name </td></tr>
    <tr><td class="paramname">namelen</td><td>strlen() of file name </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>zero for success, -errno for failure </dd></dl>

</div>
</div>
<a class="anchor" id="ab14032b74b0a57a2b3155dd6ba8d6095"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int fuse_lowlevel_notify_inval_entry </td>
          <td>(</td>
          <td class="paramtype">struct fuse_session *&#160;</td>
          <td class="paramname"><em>se</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="fuse__lowlevel_8h.html#ad119a72f00b4cd2e4a500fd3364ae1e2">fuse_ino_t</a>&#160;</td>
          <td class="paramname"><em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>namelen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Notify to invalidate parent attributes and the dentry matching parent/name</p>
<p>To avoid a deadlock don't call this function from a filesystem operation and don't call it with a lock held that can also be held by a filesystem operation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">se</td><td>the session object </td></tr>
    <tr><td class="paramname">parent</td><td>inode number </td></tr>
    <tr><td class="paramname">name</td><td>file name </td></tr>
    <tr><td class="paramname">namelen</td><td>strlen() of file name </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>zero for success, -errno for failure </dd></dl>

</div>
</div>
<a class="anchor" id="a9cb974af9745294ff446d11cba2422f1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int fuse_lowlevel_notify_inval_inode </td>
          <td>(</td>
          <td class="paramtype">struct fuse_session *&#160;</td>
          <td class="paramname"><em>se</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="fuse__lowlevel_8h.html#ad119a72f00b4cd2e4a500fd3364ae1e2">fuse_ino_t</a>&#160;</td>
          <td class="paramname"><em>ino</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">off_t&#160;</td>
          <td class="paramname"><em>off</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">off_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Notify to invalidate cache for an inode</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">se</td><td>the session object </td></tr>
    <tr><td class="paramname">ino</td><td>the inode number </td></tr>
    <tr><td class="paramname">off</td><td>the offset in the inode where to start invalidating or negative to invalidate attributes only </td></tr>
    <tr><td class="paramname">len</td><td>the amount of cache to invalidate or 0 for all </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>zero for success, -errno for failure </dd></dl>

</div>
</div>
<a class="anchor" id="ab078685b1f480188031fc40aa2e2fbca"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int fuse_lowlevel_notify_poll </td>
          <td>(</td>
          <td class="paramtype">struct fuse_pollhandle *&#160;</td>
          <td class="paramname"><em>ph</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Notify IO readiness event</p>
<p>For more information, please read comment for poll operation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ph</td><td>poll handle to notify IO readiness event for </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a58cb3543209d2c29dc2830f2503b5058"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int fuse_lowlevel_notify_retrieve </td>
          <td>(</td>
          <td class="paramtype">struct fuse_session *&#160;</td>
          <td class="paramname"><em>se</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="fuse__lowlevel_8h.html#ad119a72f00b4cd2e4a500fd3364ae1e2">fuse_ino_t</a>&#160;</td>
          <td class="paramname"><em>ino</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">off_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cookie</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieve data from the kernel buffers</p>
<p>Retrieve data in the kernel buffers belonging to the given inode. If successful then the retrieve_reply() method will be called with the returned data.</p>
<p>Only present pages are returned in the retrieve reply. Retrieving stops when it finds a non-present page and only data prior to that is returned.</p>
<p>If this function returns an error, then the retrieve will not be completed and no reply will be sent.</p>
<p>This function doesn't change the dirty state of pages in the kernel buffer. For dirty pages the write() method will be called regardless of having been retrieved previously.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">se</td><td>the session object </td></tr>
    <tr><td class="paramname">ino</td><td>the inode number </td></tr>
    <tr><td class="paramname">size</td><td>the number of bytes to retrieve </td></tr>
    <tr><td class="paramname">offset</td><td>the starting offset into the file to retrieve from </td></tr>
    <tr><td class="paramname">cookie</td><td>user data to supply to the reply callback </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>zero for success, -errno for failure </dd></dl>

</div>
</div>
<a class="anchor" id="af856725ed4a13ed7c17512554043edbc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int fuse_lowlevel_notify_store </td>
          <td>(</td>
          <td class="paramtype">struct fuse_session *&#160;</td>
          <td class="paramname"><em>se</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="fuse__lowlevel_8h.html#ad119a72f00b4cd2e4a500fd3364ae1e2">fuse_ino_t</a>&#160;</td>
          <td class="paramname"><em>ino</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">off_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structfuse__bufvec.html">fuse_bufvec</a> *&#160;</td>
          <td class="paramname"><em>bufv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="fuse__common_8h.html#aec0ad71a3e8c357ebe7e87cdecbdbe18">fuse_buf_copy_flags</a>&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Store data to the kernel buffers</p>
<p>Synchronously store data in the kernel buffers belonging to the given inode. The stored data is marked up-to-date (no read will be performed against it, unless it's invalidated or evicted from the cache).</p>
<p>If the stored data overflows the current file size, then the size is extended, similarly to a write(2) on the filesystem.</p>
<p>If this function returns an error, then the store wasn't fully completed, but it may have been partially completed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">se</td><td>the session object </td></tr>
    <tr><td class="paramname">ino</td><td>the inode number </td></tr>
    <tr><td class="paramname">offset</td><td>the starting offset into the file to store to </td></tr>
    <tr><td class="paramname">bufv</td><td>buffer vector </td></tr>
    <tr><td class="paramname">flags</td><td>flags controlling the copy </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>zero for success, -errno for failure </dd></dl>

</div>
</div>
<a class="anchor" id="ac6e2d0fde62dcf4f0e57afeabeefd7b1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fuse_lowlevel_version </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Print low-level version information to stdout. </p>

</div>
</div>
<a class="anchor" id="a8421a0cb3b6fb7013c7272c6997d1e08"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int fuse_parse_cmdline </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structfuse__args.html">fuse_args</a> *&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct fuse_cmdline_opts *&#160;</td>
          <td class="paramname"><em>opts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Utility function to parse common options for simple file systems using the low-level API. A help text that describes the available options can be printed with <code>fuse_cmdline_help</code>. A single non-option argument is treated as the mountpoint. Multiple non-option arguments will result in an error.</p>
<p>If neither -o subtype= or -o fsname= options are given, a new subtype option will be added and set to the basename of the program (the fsname will remain unset, and then defaults to "fuse").</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">args</td><td>argument vector (input+output) </td></tr>
    <tr><td class="paramname">opts</td><td>output argument for parsed options </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, -1 on failure </dd></dl>

</div>
</div>
<a class="anchor" id="ad28378dc569019c32acdb4995d70be18"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int fuse_reply_attr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="fuse__lowlevel_8h.html#a33e2aa4a8905a05397292ae047cd2257">fuse_req_t</a>&#160;</td>
          <td class="paramname"><em>req</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct stat *&#160;</td>
          <td class="paramname"><em>attr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>attr_timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reply with attributes</p>
<p>Possible requests: getattr, setattr</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">req</td><td>request handle </td></tr>
    <tr><td class="paramname">attr</td><td>the attributes </td></tr>
    <tr><td class="paramname">attr_timeout</td><td>validity timeout (in seconds) for the attributes </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>zero for success, -errno for failure to send reply </dd></dl>

</div>
</div>
<a class="anchor" id="a65431e8196e0533257acad767f7b074f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int fuse_reply_bmap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="fuse__lowlevel_8h.html#a33e2aa4a8905a05397292ae047cd2257">fuse_req_t</a>&#160;</td>
          <td class="paramname"><em>req</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>idx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reply with block index</p>
<p>Possible requests: bmap</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">req</td><td>request handle </td></tr>
    <tr><td class="paramname">idx</td><td>block index within device </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>zero for success, -errno for failure to send reply </dd></dl>

</div>
</div>
<a class="anchor" id="a300a88b63ab7c8ca92853a97486448c0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int fuse_reply_buf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="fuse__lowlevel_8h.html#a33e2aa4a8905a05397292ae047cd2257">fuse_req_t</a>&#160;</td>
          <td class="paramname"><em>req</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reply with data</p>
<p>Possible requests: read, readdir, getxattr, listxattr</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">req</td><td>request handle </td></tr>
    <tr><td class="paramname">buf</td><td>buffer containing data </td></tr>
    <tr><td class="paramname">size</td><td>the size of data in bytes </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>zero for success, -errno for failure to send reply </dd></dl>

</div>
</div>
<a class="anchor" id="abea78d22349198f8370d7cb91fbf05ed"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int fuse_reply_create </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="fuse__lowlevel_8h.html#a33e2aa4a8905a05397292ae047cd2257">fuse_req_t</a>&#160;</td>
          <td class="paramname"><em>req</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structfuse__entry__param.html">fuse_entry_param</a> *&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structfuse__file__info.html">fuse_file_info</a> *&#160;</td>
          <td class="paramname"><em>fi</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reply with a directory entry and open parameters</p>
<p>currently the following members of 'fi' are used: fh, direct_io, keep_cache</p>
<p>Possible requests: create</p>
<p>Side effects: increments the lookup count on success</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">req</td><td>request handle </td></tr>
    <tr><td class="paramname">e</td><td>the entry parameters </td></tr>
    <tr><td class="paramname">fi</td><td>file information </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>zero for success, -errno for failure to send reply </dd></dl>

</div>
</div>
<a class="anchor" id="a1242694fe0fb6e253a88b57795987302"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int fuse_reply_data </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="fuse__lowlevel_8h.html#a33e2aa4a8905a05397292ae047cd2257">fuse_req_t</a>&#160;</td>
          <td class="paramname"><em>req</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structfuse__bufvec.html">fuse_bufvec</a> *&#160;</td>
          <td class="paramname"><em>bufv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="fuse__common_8h.html#aec0ad71a3e8c357ebe7e87cdecbdbe18">fuse_buf_copy_flags</a>&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reply with data copied/moved from buffer(s)</p>
<p>Zero copy data transfer ("splicing") will be used under the following circumstances:</p>
<ol type="1">
<li>FUSE_CAP_SPLICE_WRITE is set in <a class="el" href="structfuse__conn__info.html#af45de81548b591f3004353a324e4e04d">fuse_conn_info.want</a>, and</li>
<li>the kernel supports splicing from the fuse device (FUSE_CAP_SPLICE_WRITE is set in <a class="el" href="structfuse__conn__info.html#a8a1c61f5d7cc14249fb6971165bb958e">fuse_conn_info.capable</a>), and</li>
<li><em>flags</em> does not contain FUSE_BUF_NO_SPLICE</li>
<li>The amount of data that is provided in file-descriptor backed buffers (i.e., buffers for which bufv[n].flags == FUSE_BUF_FD) is at least twice the page size.</li>
</ol>
<p>In order for SPLICE_F_MOVE to be used, the following additional conditions have to be fulfilled:</p>
<ol type="1">
<li>FUSE_CAP_SPLICE_MOVE is set in <a class="el" href="structfuse__conn__info.html#af45de81548b591f3004353a324e4e04d">fuse_conn_info.want</a>, and</li>
<li>the kernel supports it (i.e, FUSE_CAP_SPLICE_MOVE is set in <a class="el" href="structfuse__conn__info.html#a8a1c61f5d7cc14249fb6971165bb958e">fuse_conn_info.capable</a>), and</li>
<li><em>flags</em> contains FUSE_BUF_SPLICE_MOVE</li>
</ol>
<p>Note that, if splice is used, the data is actually spliced twice: once into a temporary pipe (to prepend header data), and then again into the kernel. If some of the provided buffers are memory-backed, the data in them is copied in step one and spliced in step two.</p>
<p>The FUSE_BUF_SPLICE_FORCE_SPLICE and FUSE_BUF_SPLICE_NONBLOCK flags are silently ignored.</p>
<p>Possible requests: read, readdir, getxattr, listxattr</p>
<p>Side effects: when used to return data from a readdirplus() (but not readdir()) call, increments the lookup count of each returned entry by one on success.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">req</td><td>request handle </td></tr>
    <tr><td class="paramname">bufv</td><td>buffer vector </td></tr>
    <tr><td class="paramname">flags</td><td>flags controlling the copy </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>zero for success, -errno for failure to send reply </dd></dl>

</div>
</div>
<a class="anchor" id="a672c45e126cd240f4bcd59bf9b7e3708"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int fuse_reply_entry </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="fuse__lowlevel_8h.html#a33e2aa4a8905a05397292ae047cd2257">fuse_req_t</a>&#160;</td>
          <td class="paramname"><em>req</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structfuse__entry__param.html">fuse_entry_param</a> *&#160;</td>
          <td class="paramname"><em>e</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reply with a directory entry</p>
<p>Possible requests: lookup, mknod, mkdir, symlink, link</p>
<p>Side effects: increments the lookup count on success</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">req</td><td>request handle </td></tr>
    <tr><td class="paramname">e</td><td>the entry parameters </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>zero for success, -errno for failure to send reply </dd></dl>

</div>
</div>
<a class="anchor" id="a2553c03f9a63c75e609e67f90a3a5d88"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int fuse_reply_err </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="fuse__lowlevel_8h.html#a33e2aa4a8905a05397292ae047cd2257">fuse_req_t</a>&#160;</td>
          <td class="paramname"><em>req</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>err</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reply with an error code or success.</p>
<p>Possible requests: all except forget</p>
<p>Whereever possible, error codes should be chosen from the list of documented error conditions in the corresponding system calls manpage.</p>
<p>An error code of ENOSYS is sometimes treated specially. This is indicated in the documentation of the affected handler functions.</p>
<p>The following requests may be answered with a zero error code: unlink, rmdir, rename, flush, release, fsync, fsyncdir, setxattr, removexattr, setlk.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">req</td><td>request handle </td></tr>
    <tr><td class="paramname">err</td><td>the positive error value, or zero for success </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>zero for success, -errno for failure to send reply </dd></dl>

</div>
</div>
<a class="anchor" id="adf7f34f470c04f276b7091ad3b3dcb31"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int fuse_reply_ioctl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="fuse__lowlevel_8h.html#a33e2aa4a8905a05397292ae047cd2257">fuse_req_t</a>&#160;</td>
          <td class="paramname"><em>req</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reply to finish ioctl</p>
<p>Possible requests: ioctl</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">req</td><td>request handle </td></tr>
    <tr><td class="paramname">result</td><td>result to be passed to the caller </td></tr>
    <tr><td class="paramname">buf</td><td>buffer containing output data </td></tr>
    <tr><td class="paramname">size</td><td>length of output data </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a37381eb84c39e5fe3af9f3ef507aeeb7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int fuse_reply_ioctl_iov </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="fuse__lowlevel_8h.html#a33e2aa4a8905a05397292ae047cd2257">fuse_req_t</a>&#160;</td>
          <td class="paramname"><em>req</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct iovec *&#160;</td>
          <td class="paramname"><em>iov</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reply to finish ioctl with iov buffer</p>
<p>Possible requests: ioctl</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">req</td><td>request handle </td></tr>
    <tr><td class="paramname">result</td><td>result to be passed to the caller </td></tr>
    <tr><td class="paramname">iov</td><td>the vector containing the data </td></tr>
    <tr><td class="paramname">count</td><td>the size of vector </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a940683d07df12c24f56b4363aed90e4d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int fuse_reply_ioctl_retry </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="fuse__lowlevel_8h.html#a33e2aa4a8905a05397292ae047cd2257">fuse_req_t</a>&#160;</td>
          <td class="paramname"><em>req</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct iovec *&#160;</td>
          <td class="paramname"><em>in_iov</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>in_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct iovec *&#160;</td>
          <td class="paramname"><em>out_iov</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>out_count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reply to ask for data fetch and output buffer preparation. ioctl will be retried with the specified input data fetched and output buffer prepared.</p>
<p>Possible requests: ioctl</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">req</td><td>request handle </td></tr>
    <tr><td class="paramname">in_iov</td><td>iovec specifying data to fetch from the caller </td></tr>
    <tr><td class="paramname">in_count</td><td>number of entries in in_iov </td></tr>
    <tr><td class="paramname">out_iov</td><td>iovec specifying addresses to write output to </td></tr>
    <tr><td class="paramname">out_count</td><td>number of entries in out_iov </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>zero for success, -errno for failure to send reply </dd></dl>

</div>
</div>
<a class="anchor" id="a5fbbf591a55f09c02cd54d34bdbfe0e9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int fuse_reply_iov </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="fuse__lowlevel_8h.html#a33e2aa4a8905a05397292ae047cd2257">fuse_req_t</a>&#160;</td>
          <td class="paramname"><em>req</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct iovec *&#160;</td>
          <td class="paramname"><em>iov</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reply with data vector</p>
<p>Possible requests: read, readdir, getxattr, listxattr</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">req</td><td>request handle </td></tr>
    <tr><td class="paramname">iov</td><td>the vector containing the data </td></tr>
    <tr><td class="paramname">count</td><td>the size of vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>zero for success, -errno for failure to send reply </dd></dl>

</div>
</div>
<a class="anchor" id="a135eda9b7d36fb4eaae2de58526d4f85"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int fuse_reply_lock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="fuse__lowlevel_8h.html#a33e2aa4a8905a05397292ae047cd2257">fuse_req_t</a>&#160;</td>
          <td class="paramname"><em>req</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct flock *&#160;</td>
          <td class="paramname"><em>lock</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reply with file lock information</p>
<p>Possible requests: getlk</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">req</td><td>request handle </td></tr>
    <tr><td class="paramname">lock</td><td>the lock information </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>zero for success, -errno for failure to send reply </dd></dl>

</div>
</div>
<a class="anchor" id="a85ae91390a6704dc26f8d80fed7d5678"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fuse_reply_none </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="fuse__lowlevel_8h.html#a33e2aa4a8905a05397292ae047cd2257">fuse_req_t</a>&#160;</td>
          <td class="paramname"><em>req</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Don't send reply</p>
<p>Possible requests: forget forget_multi retrieve_reply</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">req</td><td>request handle </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a170f8c6b953d70928e83bcecee43bfdc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int fuse_reply_open </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="fuse__lowlevel_8h.html#a33e2aa4a8905a05397292ae047cd2257">fuse_req_t</a>&#160;</td>
          <td class="paramname"><em>req</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structfuse__file__info.html">fuse_file_info</a> *&#160;</td>
          <td class="paramname"><em>fi</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reply with open parameters</p>
<p>currently the following members of 'fi' are used: fh, direct_io, keep_cache</p>
<p>Possible requests: open, opendir</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">req</td><td>request handle </td></tr>
    <tr><td class="paramname">fi</td><td>file information </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>zero for success, -errno for failure to send reply </dd></dl>

</div>
</div>
<a class="anchor" id="a2172d260d34c76c25cd601870aee4220"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int fuse_reply_poll </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="fuse__lowlevel_8h.html#a33e2aa4a8905a05397292ae047cd2257">fuse_req_t</a>&#160;</td>
          <td class="paramname"><em>req</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>revents</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reply with poll result event mask</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">req</td><td>request handle </td></tr>
    <tr><td class="paramname">revents</td><td>poll result event mask </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5a5872d7f73f0bd593e00788a4c7bbb7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int fuse_reply_readlink </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="fuse__lowlevel_8h.html#a33e2aa4a8905a05397292ae047cd2257">fuse_req_t</a>&#160;</td>
          <td class="paramname"><em>req</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>link</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reply with the contents of a symbolic link</p>
<p>Possible requests: readlink</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">req</td><td>request handle </td></tr>
    <tr><td class="paramname">link</td><td>symbolic link contents </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>zero for success, -errno for failure to send reply </dd></dl>

</div>
</div>
<a class="anchor" id="aa1d95ec3ca674253baac3639ea10f0ff"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int fuse_reply_statfs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="fuse__lowlevel_8h.html#a33e2aa4a8905a05397292ae047cd2257">fuse_req_t</a>&#160;</td>
          <td class="paramname"><em>req</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct statvfs *&#160;</td>
          <td class="paramname"><em>stbuf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reply with filesystem statistics</p>
<p>Possible requests: statfs</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">req</td><td>request handle </td></tr>
    <tr><td class="paramname">stbuf</td><td>filesystem statistics </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>zero for success, -errno for failure to send reply </dd></dl>

</div>
</div>
<a class="anchor" id="aa3cfa73f61d6ef461ab5a3fbf859eb97"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int fuse_reply_write </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="fuse__lowlevel_8h.html#a33e2aa4a8905a05397292ae047cd2257">fuse_req_t</a>&#160;</td>
          <td class="paramname"><em>req</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reply with number of bytes written</p>
<p>Possible requests: write</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">req</td><td>request handle </td></tr>
    <tr><td class="paramname">count</td><td>the number of bytes written </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>zero for success, -errno for failure to send reply </dd></dl>

</div>
</div>
<a class="anchor" id="afed32e5d3e1f54d390103f79ebb8bd42"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int fuse_reply_xattr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="fuse__lowlevel_8h.html#a33e2aa4a8905a05397292ae047cd2257">fuse_req_t</a>&#160;</td>
          <td class="paramname"><em>req</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reply with needed buffer size</p>
<p>Possible requests: getxattr, listxattr</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">req</td><td>request handle </td></tr>
    <tr><td class="paramname">count</td><td>the buffer size needed in bytes </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>zero for success, -errno for failure to send reply </dd></dl>

</div>
</div>
<a class="anchor" id="ad1d1963190eb93ae5667d32d2b387ca1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const struct <a class="el" href="structfuse__ctx.html">fuse_ctx</a>* fuse_req_ctx </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="fuse__lowlevel_8h.html#a33e2aa4a8905a05397292ae047cd2257">fuse_req_t</a>&#160;</td>
          <td class="paramname"><em>req</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the context from the request</p>
<p>The pointer returned by this function will only be valid for the request's lifetime</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">req</td><td>request handle </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the context structure </dd></dl>

</div>
</div>
<a class="anchor" id="a57f4dabcf044aafcdba6c4682b3a1869"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int fuse_req_getgroups </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="fuse__lowlevel_8h.html#a33e2aa4a8905a05397292ae047cd2257">fuse_req_t</a>&#160;</td>
          <td class="paramname"><em>req</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gid_t&#160;</td>
          <td class="paramname"><em>list</em>[]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the current supplementary group IDs for the specified request</p>
<p>Similar to the getgroups(2) system call, except the return value is always the total number of group IDs, even if it is larger than the specified size.</p>
<p>The current fuse kernel module in linux (as of 2.6.30) doesn't pass the group list to userspace, hence this function needs to parse "/proc/$TID/task/$TID/status" to get the group IDs.</p>
<p>This feature may not be supported on all operating systems. In such a case this function will return -ENOSYS.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">req</td><td>request handle </td></tr>
    <tr><td class="paramname">size</td><td>size of given array </td></tr>
    <tr><td class="paramname">list</td><td>array of group IDs to be filled in </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the total number of supplementary group IDs or -errno on failure </dd></dl>

</div>
</div>
<a class="anchor" id="ab3cdb9744f033e37a72984489343940f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fuse_req_interrupt_func </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="fuse__lowlevel_8h.html#a33e2aa4a8905a05397292ae047cd2257">fuse_req_t</a>&#160;</td>
          <td class="paramname"><em>req</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="fuse__lowlevel_8h.html#a5bb8b555b1d9d8a38b8c6cac28d51f1e">fuse_interrupt_func_t</a>&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Register/unregister callback for an interrupt</p>
<p>If an interrupt has already happened, then the callback function is called from within this function, hence it's not possible for interrupts to be lost.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">req</td><td>request handle </td></tr>
    <tr><td class="paramname">func</td><td>the callback function or NULL for unregister </td></tr>
    <tr><td class="paramname">data</td><td>user data passed to the callback function </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a52674fc627647f33e63c74267f0f1f9d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int fuse_req_interrupted </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="fuse__lowlevel_8h.html#a33e2aa4a8905a05397292ae047cd2257">fuse_req_t</a>&#160;</td>
          <td class="paramname"><em>req</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check if a request has already been interrupted</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">req</td><td>request handle </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if the request has been interrupted, 0 otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="aab00273c65d124e44abcf2374f9c504b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* fuse_req_userdata </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="fuse__lowlevel_8h.html#a33e2aa4a8905a05397292ae047cd2257">fuse_req_t</a>&#160;</td>
          <td class="paramname"><em>req</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the userdata from the request</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">req</td><td>request handle </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the user data passed to <a class="el" href="fuse__lowlevel_8h.html#a9ee52f81d0c63d9bd46b11314ba596cf">fuse_session_new()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a08b5503c4e9656f9c4bc88331233cc65"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fuse_session_destroy </td>
          <td>(</td>
          <td class="paramtype">struct fuse_session *&#160;</td>
          <td class="paramname"><em>se</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Destroy a session</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">se</td><td>the session </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a198429f3fbc23ef29ef9971271827690"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fuse_session_exit </td>
          <td>(</td>
          <td class="paramtype">struct fuse_session *&#160;</td>
          <td class="paramname"><em>se</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Flag a session as terminated.</p>
<p>This function is invoked by the POSIX signal handlers, when registered using <a class="el" href="fuse__common_8h.html#a292dccc3c7b1799cb054efa2ba0c774b">fuse_set_signal_handlers()</a>. It will cause any running event loops to terminate on the next opportunity.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">se</td><td>the session </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a41b12193fa1520ff658d65679f4e513c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int fuse_session_exited </td>
          <td>(</td>
          <td class="paramtype">struct fuse_session *&#160;</td>
          <td class="paramname"><em>se</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Query the terminated flag of a session</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">se</td><td>the session </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if exited, 0 if not exited </dd></dl>

</div>
</div>
<a class="anchor" id="a4bf19badb53d92d31d6b2fb131546a2d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int fuse_session_fd </td>
          <td>(</td>
          <td class="paramtype">struct fuse_session *&#160;</td>
          <td class="paramname"><em>se</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return file descriptor for communication with kernel.</p>
<p>The file selector can be used to integrate FUSE with a custom event loop. Whenever data is available for reading on the provided fd, the event loop should call <code>fuse_session_receive_buf</code> followed by <code>fuse_session_process_buf</code> to process the request.</p>
<p>The returned file descriptor is valid until <code>fuse_session_unmount</code> is called.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">se</td><td>the session </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a file descriptor </dd></dl>

</div>
</div>
<a class="anchor" id="a5f1e538aa3287e251afbe985438c4249"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int fuse_session_loop </td>
          <td>(</td>
          <td class="paramtype">struct fuse_session *&#160;</td>
          <td class="paramname"><em>se</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enter a single threaded, blocking event loop.</p>
<p>When the event loop terminates because the connection to the FUSE kernel module has been closed, this function returns zero. This happens when the filesystem is unmounted regularly (by the filesystem owner or root running the umount(8) or fusermount(1) command), or if connection is explicitly severed by writing <code>1</code> to the<code>abort</code> file in <code>/sys/fs/fuse/connections/NNN</code>. The only way to distinguish between these two conditions is to check if the filesystem is still mounted after the session loop returns.</p>
<p>When some error occurs during request processing, the function returns a negated errno(3) value.</p>
<p>If the loop has been terminated because of a signal handler installed by <a class="el" href="fuse__common_8h.html#a292dccc3c7b1799cb054efa2ba0c774b">fuse_set_signal_handlers()</a>, this function returns the (positive) signal value that triggered the exit.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">se</td><td>the session </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0, -errno, or a signal value </dd></dl>

</div>
</div>
<a class="anchor" id="a0ae949b229431e278bce6d8af271c23c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int fuse_session_loop_mt </td>
          <td>(</td>
          <td class="paramtype">struct fuse_session *&#160;</td>
          <td class="paramname"><em>se</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>clone_fd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enter a multi-threaded event loop.</p>
<p>For a description of the return value and the conditions when the event loop exits, refer to the documentation of <a class="el" href="fuse__lowlevel_8h.html#a5f1e538aa3287e251afbe985438c4249">fuse_session_loop()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">se</td><td>the session </td></tr>
    <tr><td class="paramname">clone_fd</td><td>whether to use separate device fds for each thread (may increase performance) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>see <a class="el" href="fuse__lowlevel_8h.html#a5f1e538aa3287e251afbe985438c4249">fuse_session_loop()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aa6d77679a110582684e9ca2da623bbc2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int fuse_session_mount </td>
          <td>(</td>
          <td class="paramtype">struct fuse_session *&#160;</td>
          <td class="paramname"><em>se</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>mountpoint</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Mount a FUSE file system.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mountpoint</td><td>the mount point path </td></tr>
    <tr><td class="paramname">se</td><td>session object</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, -1 on failure. </dd></dl>

</div>
</div>
<a class="anchor" id="a9ee52f81d0c63d9bd46b11314ba596cf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct fuse_session* fuse_session_new </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structfuse__args.html">fuse_args</a> *&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structfuse__lowlevel__ops.html">fuse_lowlevel_ops</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>op_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>userdata</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a low level session.</p>
<p>Returns a session structure suitable for passing to <a class="el" href="fuse__lowlevel_8h.html#aa6d77679a110582684e9ca2da623bbc2">fuse_session_mount()</a> and <a class="el" href="fuse__lowlevel_8h.html#a5f1e538aa3287e251afbe985438c4249">fuse_session_loop()</a>.</p>
<p>This function accepts most file-system independent mount options (like context, nodev, ro - see mount(8)), as well as the general fuse mount options listed in mount.fuse(8) (e.g. -o allow_root and -o default_permissions, but not <code>-o use_ino</code>). Instead of <code>-o debug</code>, debugging may also enabled with <code>-d</code> or <code>--debug</code>.</p>
<p>If not all options are known, an error message is written to stderr and the function returns NULL.</p>
<p>Option parsing skips argv[0], which is assumed to contain the program name. To prevent accidentially passing an option in argv[0], this element must always be present (even if no options are specified). It may be set to the empty string ('\0') if no reasonable value can be provided.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">args</td><td>argument vector </td></tr>
    <tr><td class="paramname">op</td><td>the (low-level) filesystem operations </td></tr>
    <tr><td class="paramname">op_size</td><td>sizeof(struct fuse_lowlevel_ops) </td></tr>
    <tr><td class="paramname">userdata</td><td>user data</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the fuse session on success, NULL on failure </dd></dl>

</div>
</div>
<a class="anchor" id="a411ee86ec4657ea954402a9ca263e6d0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fuse_session_process_buf </td>
          <td>(</td>
          <td class="paramtype">struct fuse_session *&#160;</td>
          <td class="paramname"><em>se</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structfuse__buf.html">fuse_buf</a> *&#160;</td>
          <td class="paramname"><em>buf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Process a raw request supplied in a generic buffer</p>
<p>The <a class="el" href="structfuse__buf.html">fuse_buf</a> may contain a memory buffer or a pipe file descriptor.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">se</td><td>the session </td></tr>
    <tr><td class="paramname">buf</td><td>the <a class="el" href="structfuse__buf.html">fuse_buf</a> containing the request </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa434f1c9e7d71c4ed219c4dc3b1deae7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int fuse_session_receive_buf </td>
          <td>(</td>
          <td class="paramtype">struct fuse_session *&#160;</td>
          <td class="paramname"><em>se</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structfuse__buf.html">fuse_buf</a> *&#160;</td>
          <td class="paramname"><em>buf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read a raw request from the kernel into the supplied buffer.</p>
<p>Depending on file system options, system capabilities, and request size the request is either read into a memory buffer or spliced into a temporary pipe.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">se</td><td>the session </td></tr>
    <tr><td class="paramname">buf</td><td>the <a class="el" href="structfuse__buf.html">fuse_buf</a> to store the request in </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the actual size of the raw request, or -errno on error </dd></dl>

</div>
</div>
<a class="anchor" id="ab3d015de77ae0edeb3157321e7a5c434"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fuse_session_reset </td>
          <td>(</td>
          <td class="paramtype">struct fuse_session *&#160;</td>
          <td class="paramname"><em>se</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reset the terminated flag of a session</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">se</td><td>the session </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6c10d942751ddb214863a8b5e53de5e8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fuse_session_unmount </td>
          <td>(</td>
          <td class="paramtype">struct fuse_session *&#160;</td>
          <td class="paramname"><em>se</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Ensure that file system is unmounted.</p>
<p>In regular operation, the file system is typically unmounted by the user calling umount(8) or fusermount(1), which then terminates the FUSE session loop. However, the session loop may also terminate as a result of an explicit call to <a class="el" href="fuse__lowlevel_8h.html#a198429f3fbc23ef29ef9971271827690">fuse_session_exit()</a> (e.g. by a signal handler installed by fuse_set_signal_handler()). In this case the filesystem remains mounted, but any attempt to access it will block (while the filesystem process is still running) or give an ESHUTDOWN error (after the filesystem process has terminated).</p>
<p>If the communication channel with the FUSE kernel module is still open (i.e., if the session loop was terminated by an explicit call to <a class="el" href="fuse__lowlevel_8h.html#a198429f3fbc23ef29ef9971271827690">fuse_session_exit()</a>), this function will close it and unmount the filesystem. If the communication channel has been closed by the kernel, this method will do (almost) nothing.</p>
<p>NOTE: The above semantics mean that if the connection to the kernel is terminated via the <code>/sys/fs/fuse/connections/NNN/abort</code> file, this method will <em>not</em> unmount the filesystem.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">se</td><td>the session </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Apr 10 2017 17:21:51 for libfuse by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.8
</small></address>
</body>
</html>
